\documentclass[14pt,  openany]{book}
\pagestyle{plain}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{extsizes}
\usepackage[english,russian]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyphsubst}
\usepackage{svg}
\usepackage{tempora}
\usepackage{amsmath}
\usepackage{relsize}
\usepackage{listings}
\usepackage[nottoc,notlot,notlof,numbib]{tocbibind}
\usepackage{natbib}
\usepackage{indentfirst}
\usepackage{titlesec}
\titleformat{\chapter}[display]
  {\normalfont\bfseries}{}{0pt}{\Huge}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.98,0.98,0.98}

\lstdefinestyle{mystyle}{
    frame=single,
    aboveskip=5mm,
    belowskip=5mm,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\small\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=7pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
  
\geometry{
    a4paper,
    left=30mm,
    top=20mm,
    right=15mm,
    bottom=20mm
}
\linespread{1.5}
\setlength{\parindent}{1.25cm}

\begin{document}
\chapter{Аннотация}
В современном мире много информации. И при разработке любого приложения рано или поздно возникает вопрос, как и где хранить информацию пользователей и приложения. Здесь на помощь приходит огромное количество уже существующих баз данных. И зачастую данных бывает настолько много, что неоправданно хранить их на одном компьютере. Тогда используется распределенная база данных. К современным распределенным базам данных предъявляется ряд требований. Одно из таких требований --- согласованность данных, а также изолированность транзакций.
\par Поэтому тестирование согласованности и изолированности --- это актуальный вопрос для разработчиков распределенных систем. Один из инструментов для проверки гарантий согласованности, который практически не имеет аналогов, это инструмент хаос-тестирования Jepsen. 
\par В этой работе изучен инструмент хаос-тестирования Jepsen.  Также рассмотрены различные феномены, нарушающие гарантии согласованности и изолированности, и которые вспомогательный инструмент Jepsen Elle может находить. 
\par Кроме того, проанализирована база данных Azure Cosmos DB с помощью Jepsen. В 15\% историй наблюдается G2-item аномалия которая, хоть и не противоречит заявленной в документации изоляции моментальных снимков, также нарушает заявленное в документации <<full ACID>> свойство транзакций.


\setcounter{page}{2}
\tableofcontents
\clearpage

\chapter{Введение}

Существует спрос на инструменты проверки согласованности и изоляции транзакций, так как базы данных не обеспечивают тот уровень безопасности и надежности, на который претендуют.  Они могут быть полезны по ряду причин:
\begin{itemize}
\item Пользователю(разработчику приложения, хранящего свои данные в базе данных) хочется научиться понимать про ту или иную базу данных, насколько она соответствует документации (это необходимо для того, чтобы выбрать базу данных, которая больше всего подходить для потребностей разработчика);
\item Удобный инструмент для тестирования согласованности может существенно помочь на этапе разработки распределенных систем, возможно, стать одним из этапов CI/CD процесса;
\item Jepsen проводит свои исследования независимо и в соответствии с их этической политикой. Это вносит большой вклад в сообщество, помогает в развитии и совершенствовании распределенных систем.
\end{itemize}
Большинство распределенных систем стремятся к достижению баланса между временем выполнения операций и согласованностью.  Один из инструментов для проверки гарантии согласованности --- это инструмент хаос-тестирования Jepsen.  Хаос-тестирование --- это тестирование путем внесения в систему незапланированных сбоев \cite{chaosTesting}.  Наблюдая за поведением системы, можно понять, как сделать распределенную систему более надежной. Хаос тестирование это важная часть тестирования, потому что помогает выявить состояния гонки (race condition), которые сложно иначе обнаружить в процессе разработки.

\section{Цели работы}
\begin{itemize}
  \item Получить опыт работы с выбранным инструментом проверки свойств транзакций (Jepsen);
  \item Изучить выполненные данным инструментом исследования различных баз данных;
  \item Проанализировать с помощью выбранного инструмента реальную базу данных (Azure Cosmos DB), которая еще не была проанализирована;
  \item Сравнить уровень согласованности, заявленный в документации, и уровень, установленный с помощью тестов.
\end{itemize}

\section{Основные понятия}

\emph{Параллельная система} --- это система, состоящая из независимых компонент, которые могут выполнять некоторые операции одновременно.

\emph{Распределенная система} --- это тип параллельных систем, который представляет собой систему с несколькими независимыми компонентами, расположенными на разных узлах в компьютерной сети. Эти узлы способны обмениваться данными, а также они координируют свои действия так, чтобы для конечного пользователя распределенная система работала как единая согласованная система. Система имеет логическое состояние, которое меняется с течением времени.

\emph{Хаос-тестирование \cite{chaosTesting}} --- это тестирование путем внесения в распределенную систему незапланированных сбоев.

\emph{Процесс} --- это логически однопоточная программа, которая способна выполнять некоторые операции.

\emph{Операция} --- переход из одного состояние в другое.

\emph{Атомарная операция} --- операция в общей области памяти, которая завершается за один шаг относительно других потоков, имеющих доступ к этой области памяти. Во время выполнения такой операции над переменной ни один поток не может наблюдать изменение наполовину завершенным. Неатомарные операции не дают такой гарантии. \cite{habrAtomicOperation}

\emph{Параллелизм} --- это свойство системы, которое означает, что несколько процессов могут выполняться в одно и то же время.

\emph{Сбой} --- это состояние процесса, в котором тот не может вызывать никаких операций. Если операция по какой-то причине не была завершена и не имеет времени завершения, то ее следует рассматривать одновременно с каждой операцией, которая будет вызвана после. Это нарушает требования на однопоточность процесса, поэтому в этой работе будет говориться о состоянии сбоя процесса.

\emph{История} --- совокупность операций и их параллельной структуры. В этой работе будет рассматриваться истории с точки зрения Jepsen. То есть истории будут представлены в виде упорядоченного списка операций вызова и завершения.

\emph{Модель согласованности} --- набор гарантий, используемый в той или иной распределенной системе, для обеспечения согласованности данных.

\emph{Транзакция} --- некоторый конечный набор операций, переводящий данные из одного согласованного состояния в другое. Либо будет выполнена каждая операция из набора, либо ни одной.

\emph{ACID} --- основные свойства транзакций: атомарность, согласованность, изолированность и прочность.

\emph{Согласованность} --- свойство транзакций, которое гарантирует, что каждая успешно завершенная транзакция фиксирует результат, являющийся допустимым с точки зрения внутренних правил базы данных. Когда же какая-то транзакция пытается записать несогласованные данные, вся транзакция откатывается, транзакция завершается с ошибкой.

\emph{Изоляция} --- свойство транзакций, которое гарантирует, что параллельно исполняющиеся транзакции не влияют на результаты друг друга.  Полную изоляцию тяжело поддерживать, поэтому в реальных данных поддерживаются различные более слабые уровни изоляции.

\emph{Happens before} --- A happens-before B означает, что все изменения, выполненные потоком X до момента операции A и изменения, которые повлекла эта операция, видны потоку Y в момент выполнения операции B и после выполнения этой операции. Отметим, что операцию А исполняет поток X и операцию B исполняет поток Y. \cite{habrMemoryModel}

% \section{План работы}

\chapter{Основные теоретические сведения}
В этой главе будут рассмотрены основные теоретические сведения, которые будут полезны в практической части.
\section{Базы данных}
База данных --- это некоторое хранилище данных.  Чаще всего в данной работе будут рассматриваться распределенных базах данных, то есть таких базы данных,  которые хранят некоторые части своих данных в различных физических локациях.
\par
Основное требование к базам данных --- это поддержание какого-то внутреннего консистентного состояния данных. Иными словами, согласованность и целостность, непротиворечивость данных в каждый момент времени.
\par
Различные базы данных добиваются этого разными способами. Реляционные базы данных предоставляют механизм транзакций, который гарантирует согласованность данных. Чтобы ускорить работу с данными, базы данных используют некоторый механизм блокировок, который теоретически гарантирует консистентное состояние. Однако, это не всегда правда.
\par
Некоторые базы данных реализуют различные модели согласованности, позволяющие регулировать гарантии, предоставляемые базой данных. Далее будет рассмотрена наиболее часто встречаемая модель согласованности, реализуемая различными базами данных, в том числе Azure Cosmos DB.

\section{Изоляция моментальных снимков(англ.  \textit{Snapshot Isolation})\cite{jepsenConsistencyModels}}
Изоляция моментальных снимков --- это транзакционная модель. Нет гарантии доступности, то есть распределенная система может быть недоступна во время некоторых типов сетевых сбоев. Некоторые или все узлы должны приостановить работу, чтобы обеспечить безопасность.

\par Изменения транзакции видны только этой транзакции до момента фиксации, когда все изменения становятся видимыми атомарно. Если транзакция $T_1$ изменила объект \textit{x}, а другая транзакция $T_2$ совершила запись в \textit{x} после начала моментального снимка $T_1$ и до фиксации $T_1$, то $T_1$ должна прерваться.
\par
В отличие от сериализуемости(англ. \textit{Serializability}), которая обеспечивает полный порядок транзакций, изоляция моментальных снимков гарантирует только частичный порядок: подоперации в одной транзакции могут чередоваться с подоперациями из других транзакций. Наиболее заметными явлениями, допускаемыми изоляцией моментальных снимков, являются перекосы записи (англ. \textit{write skews}), которые позволяют транзакциям считывать перекрывающееся состояние, изменять непересекающиеся наборы объектов, а затем фиксировать; и аномалия транзакций только для чтения(англ.  \textit{read-only transaction anomaly}), включающая частично непересекающиеся наборы записи.
\par
Данная модель согласованности запрещает грязную запись (англ. \textit{Dirty Write}, $P_0$) и грязное чтение (англ.  \textit{Dirty Read}, $P_1$), но допустимы неповторяющееся чтение (англ. \textit{Fuzzy Read}, $P_2$), фантомное чтение (англ. \textit{Phantom}, $P_3$)\cite{adya99:_weak_consis}. Изоляция моментальных снимков не накладывается никаких ограничений в реальном времени и не требует упорядочивания процессов между транзакциями.
\par
\cite {BerensonIsolationLevels} В терминах абстрактного алгоритма можно говорить о данной модели согласованности так: каждая транзакция считывает данные из моментального снимка зафиксированных данных на момент начала транзакции, называемого ее меткой начала отсчета. Это время может быть любым до первого чтения транзакции. Транзакция никогда не блокируется при попытке чтения до тех пор, пока данные моментального снимка из его метки начала отсчета могут быть сохранены. Записи транзакции (обновления, вставки и удаления) также будут отражены в этом моментальном снимке, чтобы их можно было считать снова, если транзакция обращается к данным во второй раз. Обновления другими транзакциями, начатыми после метки начала отсчета транзакции, невидимы для транзакции. 
\par
Когда транзакция $T_1$ готова к фиксации, она получает метку времени фиксации, которая больше любой существующей метки начала отсчета или другой метки времени фиксации. Транзакция будет зафиксирована только в том случае, если ни одна другая транзакция $T_2$ с меткой времени фиксации в интервале выполнения $T_1$ [время начала отсчета, время фиксации] не записала данные, которые также записала $T_1$. В противном случае $T_1$ прервется. Это предотвращает потерю обновлений. Когда $T_1$ будет зафиксирована, эти изменения становятся видимыми для всех транзакций, метки начала отсчета которых больше, чем метка времени фиксации $T_1$.
\par
В другой формулировке изоляции моментальных снимков определяется как комбинация четырех свойств \cite{cerone_et_al}:
\begin{itemize}
\item внутренняя согласованность (англ. \textit{internal consistency});
\item внешняя согласованность (англ. \textit{external consistency});
\item префикс (англ. \textit{prefix}) --- здесь и далее это означает, что транзакции становятся видимыми для всех узлов в одном и том же порядке;
\item отсутствие конфликта (англ. \textit{NoConflict}) --- здесь и далее это означает, что если две транзакции изменяют один и тот же объект, одна должна быть видна другой.
\end{itemize}

\section{Граф сериализации \cite{IsolationLevelDefinitions} \cite{IsolationLevelDefinitions2}}
Сначала будут определены различные типы зависимостей, которые возникают между транзакциями, а затем через них определен \textit{граф сериализации}(\textit{\textbf{DSG}}). 
Здесь и далее $T_i/T_j$ - транзакции.
\subsection{Зависимость записи (англ. \textit{Directly Write-Depends})}
В дальнейшем будет использоваться обозначение для данного типа зависимости: \textit{ww}. Обозначение в \textit{DSG}: $T_i  \xrightarrow{\textit{ww}} T_j$
\par
Описание: $T_j$ зависит от $T_i$, когда $T_i$ устанавливает $x_i$, а $T_j$ устанавливает следующую версию \textit{x}.

\subsection{Зависимость чтения (англ. \textit{Directly Read-Depends})}
В дальнейшем будет использоваться обозначение для данного типа зависимости: \textit{wr}. Обозначение в \textit{DSG}: $T_i  \xrightarrow{\textit{wr}} T_j$
\par
Описание: $T_j$ зависит от $T_i$,  когда выполняется одно из двух условий:
\begin{itemize}
\item $T_i$ устанавливает $x_i$, $T_j$ читает $x_i$;
\item $T_i$ фиксирует изменение, а затем $T_j$ выполняет чтение на основе предикатов таким образом, что набор объектов, соответствующих предикату, изменяется фиксацией $T_i$.   Кроме того, $T_i$ --- это самая последняя транзакция, в которой было зафиксировано изменение, влияющее на соответствие $T_i$.
\end{itemize}

\subsection{Анти зависимость (англ. \textit{Directly Anti-Depends})}
В дальнейшем будет использоваться обозначение для данного типа зависимости: \textit{rw}. Обозначение в \textit{DSG}: $T_i  \xrightarrow{\textit{rw}} T_j$
\par
Описание: $T_j$ зависит от $T_i$,  когда выполняется одно из двух условий:
\begin{itemize}
\item $T_i$ считывает некоторую версию $x_i$ объекта \textit{x}, а затем $T_j$  фиксирует следующую версию \textit{x} в истории версий;
\item $T_i$ выполняет чтение на основе предикатов, а $T_j$ перезаписывает это чтение(то есть фиксирует более позднюю, следующую версию  объекта).
\end{itemize}

\subsection{Граф сериализации(англ. \textit{Direct Serialization Graph}, \textit{DSH})}
DSG имеет один узел для каждой совершенной транзакции. Направленные ребра между этими узлами представляют зависимости чтения/записи/анти. Транзакция $T_2$ зависит от $T_1$, если в графе есть путь от $T_1$ до $T_2$. 
\par
Построение DSG начинается с добавления узлов для каждой зафиксированной транзакции. Затем добавляется ребро \textit{wr}, \textit{rw} или \textit{ww} зависимости для всех пар транзакций, если выполняются условия зависимости.

\section{Феномены}
\subsection{Грязная запись (англ.  \textit{Dirty Write},  $P_0$) \cite{CritiqueANSI_SQL}}
Грязная запись происходит, когда одна транзакция перезаписывает значение, которое ранее было записано другой транзакцией, все еще находящейся в процессе исполнения.
\par Одна из причин, по которой грязные записи плохи, заключается в том, что они могут нарушить согласованность базы данных. Если, например, между \textit{x} и \textit{y} существует ограничение (например, $x = y$), и транзакции $T_1$ и $T_2$ поддерживают согласованность ограничения, если эти транзакции исполняются отдельно. Однако ограничение может быть легко нарушено, если две транзакции записывают \textit{x} и \textit{y} в разных порядках, что может произойти только при наличии грязных записей.
\par Еще одна причина необходимости защиты от грязных записей заключается в том, что без защиты от них система не может автоматически откатиться к образу <<до>> при прерывании транзакции.

\subsection{Грязное чтение (англ. \textit{Dirty Read}, $P_1$)}
Грязное чтение --- явление, когда одна транзакция считывает изменения, внесенные другими незафиксированными (или даже прерванными) транзакциями. \cite{sookocheff}
\par Недостаточно предотвратить только чтение значений, записанных транзакциями, которые в конечном итоге откатываются. Также необходимо предотвратить чтение значений из транзакций, которые в конечном итоге также фиксируются.  \cite{CritiqueANSI_SQL}

\subsection{Неповторяющееся чтение (англ. \textit{Fuzzy Read}, $P_2$)}
Неповторяющееся чтение --- это явление, которое возникает, когда значение считывается дважды во время транзакции, и эти считанные значения отличается между чтениями.  Это возможно, когда значение, считанное транзакцией, все еще находящейся в процессе исполнения, перезаписывается другой транзакцией. Даже без повторного считывания значения, которое фактически происходит, это все равно может привести к нарушению инвариантов базы данных.  \cite{CritiqueANSI_SQL}

\subsection{Фантомное чтение (англ. \textit{Phantom}, $P_3$)}
Фантомное чтение происходит, когда транзакция выполняет два идентичных запроса во время обработки, но возвращаемые результаты этих двух запросов различны.  \cite{sookocheff}

\subsection{G0 (цикл записи, англ. \textit{Write Cycle})}
История содержит аномалию \textit{цикл записи}, если ее граф сериализации содержит цикл, полностью состоящий из ребер зависимости записи(\textit{ww}). 
\par Цикл записи происходит, когда две транзакции записывают один и тот же набор данных. Предотвращение циклов записи является минимальным требованием для наличия функциональной базы данных, гарантируя, что записи, выполняемые транзакцией \textit{A}, не перезаписываются транзакцией \textit{B}, пока транзакция \textit{A} все еще выполняется.  \cite{sookocheff}

\subsection{G1}
G1: включает в себя три феномена: 
\begin{itemize}
\item G1a (прерванное чтение, англ. \textit{aborted read}) --- $T_2$ считывает некоторый объект (в том числе с помощью чтения предикатов), измененный $T_1$, и $T_1$ прерывается. Чтобы предотвратить прерывание чтения, если $T_2$ читает из $T_1$ и $T_1$ прерывается, $T_2$ также должен прерваться;
\item G1b (промежуточное чтение, англ. \textit{intermediate read}) --- $T_2$ считывает версию некоторого объекта (в том числе с помощью чтения предикатов), измененную $T_1$, и это не было окончательной модификацией этого объекта $T_1$. Чтобы предотвратить промежуточное чтение, транзакции могут быть разрешены к фиксации только в том случае, если они прочитали окончательные версии объектов из других транзакций;
\item G1c (циклический информационный поток, англ. \textit{сyclic information flow}) --- граф сериализации содержит направленный цикл, полностью состоящий из ребер зависимостей (чтение и запись). Если на $T_1$ влияет $T_2$, то нет никакого пути, по которому $T_2$ также может влиять на $T_1$.
\end{itemize}

\subsection{G2-item (цикл антизависимости, англ. \textit{anti-dependency cycle})}
G2-item(anti-dependency cycle, цикл антизависимости) возникает, когда граф сериализации \textit{DSG} содержит направленный цикл, имеющий одно или несколько ребер антизависимости(\textit{rw}). 

\chapter{Методология проверки согласованности распределенных систем}
В предудущей главе были рассмотрены некоторые нарушения и аномалии,которые нарушают гарантии согласованности распределенной системы. Несмотря на то, что они встречаются довольно часто,их сложно обнаружить.  В этой главе будет рассмотрен инструмент, разработанный специально для проверки того, соответствует ли распределенная система и ее транзакции своим гарантиям согласованности и изолированности.
\section{Jepsen}
\begin{figure}[H]
  \includegraphics[width=\textwidth]{jepsen.jpeg}
  \caption{Схема работы Jepsen-тестирования}
\end{figure}
\par
Jepsen --- это библиотека для функционального языка Clojure.
\par
Jepsen проверяет систему, генерируя случайные последовательности операции (например, чтение, запись, cas) в распределенной системе, записывая метку времени и продолжительность каждой операции, а также создавая модель системы в памяти.  Также Jepsen может генерировать последовательности транзакций из различных операций. А затем он пытается доказать, имеет ли история событий смысл с учетом заданной модели согласованности.
\par
Jepsen также может генерировать разные сбоев в распределенной системе, например, проблемы с сетью, уничтожение компонентов, а также генерацию случайной нагрузки.
\par
При запуске теста jepsen сначала подключается по ssh к каждому узлу, загрузит, распакует и настроит на них распределенную систему.
После запускаются клиентские процессы. и процессы-сбои (англ. \textit{nemesis}). Во время теста в jepsen есть два типа процессов: один - клиент, который будет выполнять различные операции с системой (с интервалом и частотой, заданных в генераторе), а другой - nemesis, который будет вносить сбои и разрушения и выполнять восстановление системы. После завершения операций jepsen будет использовать checker (после jepsen 2.0 это будет Elle), чтобы проверить правильность истории операций с определенными моделями согласованности.

\subsection{Как анализировать результаты}
При каждом запуске jepsen создает новый каталог в \textit{store/} директории, и мы можем увидеть последние результаты в папке \textit{store/latest}. Там лежат несколько файлов.  Файл \textit{history.txt} содержит операции, которые выполнял тест.  Файл \textit{jepsen.log} --- копия консоли для этого запуска, \textit{jepsen.log} есть журнал всех операций, выполненных jepsen к тестируемой системе, и ,наконец, \textit{test.fressian} --- это необработанные данные теста, включающие полную историю операций, \textit{timeline.html} --- это html документ, который показывает удобную временную шкалу операций. Эта шкала очень полезный инструмент для понимания порядка операций в тесте и выявления причин несогласованности результатов теста. Синий цвет указывает на то, что операция прошла успешно, красный - на неудачную операцию (состояние системы не изменилось), а оранжевый - на неопределенную операцию.

\section{Elle}
\par
Elle --- это инструмент для анализа транзакций. Он способен автоматически выводить график логического порядка транзакций и искать циклы в этом графике для выявления нарушений согласованности. Например, если транзакции образуют логический цикл, то невозможно сказать, какая транзакция произошла до и после, а значит, нарушается гарантия линеаризуемости. 
Дополнительно проверяется наличие прерванных и промежуточных считываний и другие нарушения.
\par
Elle не является полным: он может не идентифицировать аномалии, которые присутствовали в тестируемой системе. Это следствие двух факторов:
\begin{itemize}
\item Elle проверяет истории, наблюдаемые в реальных базах данных, где результаты транзакций могут остаться незамеченными, а информация о времени может быть не такой точной, как хотелось бы;
\item проверка сериализуемости является NP-полной задачей; Elle намеренно ограничивает свои выводы теми, которые можно решить за линейное (или лог-линейное) время.
\end{itemize}
\subsection{Список возможных аномалий}
\begin{itemize}
\item G0 (цикл записи), 
\item G1a (прерванное чтение), 
\item G1b (промежуточное чтение), 
\item G1c (cyclic information flow, циклический поток информации), 
\item G-single (read skew, перекос чтения) ,
\item G2-item (anti-dependency cycle, цикл антизависимости)).
\end{itemize}

\par Инструмент также умеет проверять согласованность внутри одной транзакции: то есть можно проверить, что транзакции считывают значения, соответствующие их собственным предыдущим записям, нет дублирующихся элементов и неожиданных элементов (например, элементов, которые никогда не были записаны).

\chapter{Исследование согласованности Azure Cosmos DB}
\section{Azure Cosmos DB}
Azure Cosmos DB - это коммерческий (с закрытым исходным кодом) глобально распределенный многомодельный сервис баз данных Microsoft <<для управления данными в планетарном масштабе>>, запущенный в мае 2017 года. Он не зависит от схемы, горизонтально масштабируем и обычно классифицируется как база данных NoSQL.
\par Cosmos DB поддерживает несколько API: SQL, Cassandra, MongoDB, Gremlin, Table. Здесь под SQL подразумевается документ-ориентированный API, который раньше назывался DocumentDB, и он значительно отличается от привычных реляционных баз данных.
\par Документная модель Cosmos DB хранит данные в контейнерах (\textit{containers}), состоящих из элементов (\textit{items}). Все настройки масштабирования, пропускной способности, индексирования указываются на уровне контейнера. База данных, по большому счету --- именованное объединение контейнеров.

\section{Дизайн теста}
Мы разработали тест с использованием библиотеки для тестирования распределенных систем Jepsen. Будем использовать его для оценки безопасности транзакций в Azure Cosmos DB. 
\subsection{Append тест}
Генератор транзакций Jepsen генерировал транзакции, состоящие из последовательности операций. Длину последовательности операций можно настраивать, для запуска тестов использовалась длина 4. Каждая операция в последовательности --- это либо чтение массива значений по ключу id, либо добавление уникального целого числа в массив значений по ключу id. 
\par
Далее, используя Elle для анализа транзакций, Jepsen строит граф сериализации для каждой истории и ищет циклы для выявления аномалий. 

\section{Список возможных параметров для теста}


\section{О реализации транзакций в Azure Cosmos DB}
\subsection{TransactionalBatch}
TransactionalBatch --- это, как утверждает документация, способ задания транзакции из нескольких операций (create, read, update, upsert, delete). Эти операции либо успешно выполнятся все вместе, либо завершатся сбоем.  В TransactionalBatch операции выполняются с одним и тем же ключом секции в контейнере.  Итак, если все операции выполняются успешно в том порядке, в котором они описаны в транзакционной пакетной операции, транзакция будет зафиксирована. Однако при сбое любой операции выполняется откат всей транзакции.
\par TransactionalBatch способствует увеличению производительности транзакций, как заявлено в документации.
\par При тестировании транзакций с использованием TransactionalBatch Elle обнаружила следующие аномалии:
\begin{itemize}
\item внутренняя несогласованность (англ. \textit{Internal Inconsistency}) --- транзакция не соблюдает свои собственные предыдущие операции чтения и записи.
\item несогласованный порядок версий (англ.\textit{Inconsistent Version Orders}) --- правила вывода предполагают циклический порядок обновления одного ключа.
\end{itemize}
Также, из отношений между аномалиями Elle\cite{Kingsbury2020ElleII} можно заключить, что из обнаружение в истории  \textit{Inconsistent Version Orders} аномалии следует, что \textit{G1a} аномалия там также присустствует.
\par Кроме того, на уровнях \textbf{Ограниченное устаревания} и \textbf{Случайная} была обнаружена \textit{G2-item} аномалия. 
\par Напомним, что обнаружение этой аномалии означает, что граф сериализации(\textit{DSG}) содержит направленный цикл с одним или несколькими ребрами анти зависимости \cite{IsolationLevelDefinitions}.

\par Транзакции теряют подтвержденные записи.  Кроме того, оказывается, что транзакции не изолированы. То есть,транзакции в такой реализации могли влиять на результаты других транзакций.
А значит, TransactionalBatch в нашей задаче использовать нельзя.

\subsection{Хранимые процедуры(англ. \textit{Stored procedures})}
Azure Cosmos DB обеспечивает транзакционное выполнение JavaScript кода. При использовании API SQL в  Cosmos DB можно писать хранимые процедуры, триггеры и определяемые пользователем функции (UDF) на языке JavaScript. 
\par Только документы из одного и того же логического раздела могут быть включены в одну транзакцию.  Соответственно, операции записи в разные контейнеры не могут быть выполнены транзакционно. Время выполнения одной хранимой процедуры ограничено (5 секунд), и если длительность транзакции выходит за эти рамки, она будет отменена. Есть способы реализации <<долгоживущих>> транзакций через несколько обращений к серверу, но они нарушают атомарность.
\par Помимо того, что написанный JavaScript код будет выполняться атомарно, также данный  способ реализации транзакций обещает хорошую производительность. Можно назвать следующие преимущества:
\begin{itemize}
\item \textit{пакетная обработка} --- это сократит затраты сетефого трафика и накладные расходы на хранение
\item  \textit{предварительная компиляция} --- хранимые процедуры, триггеры и определяемые пользователем функции неявно предварительно скомпилированы в формат байтового кода, чтобы избежать затрат на компиляцию во время каждого вызова скрипта. Благодаря предварительной компиляции скорость хранимой процедуры высокая, а занимаемая память небольшая.
\end{itemize}
\par
Хранимые процедуры и триггеры всегда выполняются на основной реплике контейнера Azure Cosmos. Эта возможность гарантирует, что операции чтения в хранимых процедурах обеспечивают сильную согласованность. 

\section{Модель согласованности транзакций}
Что же утверждает документация Azure Cosmos DB касательно транзакций? Давайте посмотрим.
Транзакции базы данных обеспечивают безопасную и предсказуемую модель программирования для обработки одновременных изменений данных. Традиционные реляционные базы данных позволяют писать бизнес-логику с помощью хранимых процедур и/или триггеров, отправлять ее на сервер для выполнения непосредственно в ядре базы данных. 
\par
В Azure Cosmos DB поддерживаются транзакции, полностью совместимые с ACID (атомарность, согласованность, изоляция, прочность). В документации утверждается, что поддерживаемый уровень изоляции транзакций - \textbf{изоляция моментальных снимков}.  Это достаточно сильная модель, которая представляет собой базовый уровень согласованности для таких систем, как PostgreSQL. 

\section{Описание кластера для тестирования}
В данном исследовании мы будем запускать кластер Jepsen на одном компьютере, используя docker compose.  Это упрощает и стандартизирует выполнение тестов. 
\par Репозиторий Jepsen предоставляет базовые настройки для запуска тестов в докере. Он поддерживает 3 вида контейнеров:  
\begin{itemize}
\item jepsen-control:  управляет другими узлами, настройкой и удалением, генерирует данные и сбои;
\item jepsen-nX:  один из узлов в кластере(по умолчанию таких узлов 5);
\item jepsen-node: используется агентом для создания сбоев (nemesis). 
\end{itemize}

\section{Результаты}
При тестировании Azure Cosmos DB, где мы реализовали транзакции с помощью хранимых процедур(англ. \textit{Stored procedures}), на всех уровнях согласованности(мы запускали тесты с разными параметрами, в том числе на разных уровных согласованности: сильная, ограниченное устаревание,сеанс, префикс и случайная) были замечены G2-item  аномалии. Давайте посмотрим на несколько примеров примеры таких аномалий и попытаемся понять,противоречит ли данная аномалия требованиям к Azure Cosmos DB, заявленным в документации.
\subsection{Тестирование базового уровня}
Мы начали с того, что запустили наши тесты в упрощенном варианте, чтобы получить базовый уровень: каждая транзакция Jepsen выполняла только одну операцию чтения или добавления.
Полученные истории оказались совместимыми с \textbf{изоляцией моментальных снимков}.

\subsection{Обозначения для графиков}
Транзакции, изображенные на графиках аномалий, могут состоять из двух типов операций.
\subsubsection{Чтение (англ. \textit{read})}
\begin{figure}[H]
\centering
  \includegraphics[scale=1.0]{images/read.png}
  \caption{Обозначение для операции чтения}
\end{figure}
Так будет обозначаться операция чтения в транзакции. \textit{r} --- операция чтения, \textit{\textbf{k}} --- \textit{id} объекта в таблице, который считывается. $[v_1 v_2 ... v_i]$ - сам объект, который был считан, массив целых чисел. Допускается, что может быть считан пустой массив, тогда он обозначается как $[]$.

\subsubsection{Добавление (англ. \textit{append})}
\begin{figure}[H]
\centering
  \includegraphics[scale=1.0]{images/append.png}
  \caption{Обозначение для операции добавления}
\end{figure}
Так будет обозначаться операция добавления нового элемента в транзакции. \textit{a} --- операция добавления, \textit{\textbf{k}} --- \textit{id} объекта в таблице,  к которому требуется добавить значение. \textit{v} - значение, которое должно быть добавлено в конец массива целых чисел, который уже хранится.

\subsection{G2-item (англ. \textit{anti-dependency cycle}, цикл антизависимости)}
\subsubsection{\textit{Пример 1}}
\begin{figure}[H]
  \includegraphics[width=\textwidth]{images/g2item1.png}
  \caption{G2-item}
\end{figure}

\par
Данная аномалия найдена при тестировании с использованием следующих параметров: 
\begin{itemize}
\item[] \textit{уровень согласованности} --- ограниченное устаревание(англ.  \textit{bounded staleness})
\item[] \textit{количество потоков} --- 15
\item[] \textit{лимит времени на транзакцию} --- 120 секунд
\item[] \textit{ограничение на количество элементов по одному ключу} --- 128
\item[] \textit{максимальное количество операций в транзакции} --- 4
\end{itemize}

\textbf{Транзакция 1} выполняет операции:
\begin{enumerate}
\item добавление числа \textit{31} к массиву под \textit{id} \textit{\textbf{39}}
\item чтение массива значений по \textit{id} \textit{\textbf{42}} $\rightarrow$ получен пустой массив \textit{[ ]}
\item добавление числа \textit{4} к массиву под \textit{id} \textit{\textbf{41}}
\end{enumerate}

\textbf{Транзакция 2} выполняет операции:
\begin{enumerate}
\item добавление числа \textit{1} к массиву под \textit{id} \textit{\textbf{42}}
\item чтение массива значений по \textit{id} \textit{\textbf{41}} $\rightarrow$ получен массив $[1 2 3]$
\end{enumerate}

Ребро анти зависимости \textit{rw} добавляется между операцией 2 транзакции 1 и операций 1 транзакции 2 потому что операция 2 транзакции 1  считала некоторую(\textit{[ ]}) версию объекта с \textit{id} \textbf{42},  а операция 1 транзакции 2 изменила этот объект, добавив в массив значений новое число \textit{\textbf{1}}.  Также ребро анти зависимости \textit{rw} добавляется между операцией 2 транзакции 2 и операцией 3 транзакции 1, потому что операция 2 транзакции 2  считала некоторую(\textit{[1 2 3]}) версию объекта с \textit{id} \textbf{41},  а операция 3 транзакции 1 изменила этот объект, добавив в массив значений новое число \textit{\textbf{4}}.  В полученном графе сериализации наблюдается направленный цикл, содержащий 2 ребра анти зависимости. Значит, по определению, найдена \textit{G2-item} аномалия.

\par Эти две транзакции невозможно изолировать: если бы первая транзакция выполнялась первой, изолированно, ее запись с \textit{id} 41 была бы видна второй транзакции --- и наоборот. Но поскольку эти транзакции не записывались в один и тот же \textit{id}, им разрешено (при \textbf{изоляции моментальных снимков}) выполняться одновременно.

\subsubsection{\textit{Пример 2}}
\begin{figure}[H]
  \includegraphics[width=\textwidth]{images/g2item2.png}
  \caption{G2-item}
\end{figure}

\par Данная аномалия найдена при тестировании с использованием следующих параметров: 
\begin{itemize}
\item[] \textit{уровень согласованности} --- постоянный префикс(англ.  \textit{consistent prefix})
\item[] \textit{количество потоков} --- 15
\item[] \textit{лимит времени на транзакцию} --- 120 секунд
\item[] \textit{ограничение на количество элементов по одному ключу} --- 128
\item[] \textit{максимальное количество операций в транзакции} --- 7
\end{itemize}

Это более сложный цикл, состоящий из 4 транзакций.  Каждая из этих транзакций зависит от другой.  \par

Транзакция 1(\textbf{$T_1$}) выполняет операции:
\begin{enumerate}
\item добавление числа \textit{26} к массиву под \textit{id} \textit{\textbf{48}}
\item чтение массива значений по \textit{id} \textit{\textbf{48}} $\rightarrow$ получен массив \textit{[2 3 4 5 6 7 8 9 1 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 27 28 29 30 31 26]}
\end{enumerate}

\par Транзакция 2(\textbf{$T_2$}) выполняет операцию:
\begin{enumerate}
\item чтение массива значений по \textit{id} \textit{\textbf{48}} $\rightarrow$ получен массив \textit{[2 3 4 5 6 7 8 9 1 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 27 28 29 30 31 26]}
\end{enumerate}

\par Транзакция 3(\textbf{$T_3$}) выполняет операции:
\begin{enumerate}
\item добавление числа \textit{32} к массиву под \textit{id} \textit{\textbf{48}}
\item чтение массива значений по \textit{id} \textit{\textbf{46}} $\rightarrow$ получен массив \textit{[1 3 4 5 6 2 8 9 10 7 11 13 12 14 15 17 21 22 18 19 16 23 24 25 26 27 29 30 31 20 33 36 35 32 28 34 38 37 39 40 41 42 44]}
\end{enumerate}

\par Транзакция 4(\textbf{$T_4$}) выполняет операции:
\begin{enumerate}
\item чтение массива значений по \textit{id} \textit{\textbf{48}} $\rightarrow$ получен массив \textit{[2 3 4 5 6 7 8 9 1 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 27 28 29 30 31]}
\item добавление числа \textit{45} к массиву под \textit{id} \textit{\textbf{46}}
\end{enumerate}

Далее обозначение \textbf{$T_1$}.1 означает операцию 1 транзакции 1.  

\par \textbf{Ребра:}
\begin{itemize}
\item \textit{rw} --- \textbf{$T_4$}.1 $ \xrightarrow{\textit{rw}}$  \textbf{$T_1$}.1,  так как \textbf{$T_4$}.1 считывает массив по $id=48$ и получает массив значений без числа $26$, а \textbf{$T_1$}.1 изменяет массив, добавляя в него новое число $26$;
\item \textit{rw} --- \textbf{$T_2$}.1 $ \xrightarrow{\textit{rw}}$  \textbf{$T_3$}.1,  так как \textbf{$T_2$}.1 считывает массив по $id=48$ и получает массив значений без числа $32$, а \textbf{$T_3$}.1 изменяет массив, добавляя в него новое число $32$;
\item \textit{rw} --- \textbf{$T_3$}.2 $ \xrightarrow{\textit{rw}}$  \textbf{$T_4$}.2,  так как \textbf{$T_3$}.2 считывает массив по $id=46$ и получает массив значений без числа $45$, а \textbf{$T_4$}.2 изменяет массив, добавляя в него новое число $45$;
\item \textit{ww} --- \textbf{$T_1$}.1 $ \xrightarrow{\textit{ww}}$  \textbf{$T_3$}.1, так как транзакции изменяют один и тот же объект $id=48$, одна транзакция добавляет число $26$, а другая $32$;
\item \textit{wr} --- \textbf{$T_1$}.1 $ \xrightarrow{\textit{wr}}$  \textbf{$T_2$}.1, так как \textbf{$T_2$}.1 считала массив значений объекта $id=48$ и в массиве содержалось число $26$, добавленное транзакцией \textbf{$T_1$}.1.
\end{itemize}
В полученном графе сериализации наблюдается направленный цикл, содержащий 3 ребра анти зависимости. Значит, по определению, найдена \textit{G2-item} аномалия.
\par Если пытаться упорядочить данные транзакции, то наблюдается следующее поведение ($T_i<T_j$ --- транзакция $T_i$ произошла раньше $T_j$):
\begin{itemize}
\item $T_2 < T_3$, так как $T_2$ не наблюдает число $32$, добавленное в транзакции $T_3$; 
\item $T_3 < T_4$, так как $T_3$ не наблюдает число $45$, добавленное в транзакции $T_4$; 
\item $T_4 < T_1$, так как $T_4$ не наблюдает число $26$, добавленное в транзакции $T_1$;
\item $T_1 < T_2$, так как $T_2$ наблюдает число $26$, добавленное в транзакции $T_1$.  
\end{itemize}
Получили противоречие. Эти четыре транзакции невозможно изолировать.

\subsection{Выводы}
В этом параграфе будет рассмотрено, что означает найденная \textit{G2-item} аномалия. В документации Azure Cosmos DB сказано, что транзакции полностью атомарны, изолированы,согласованы и прочны(<<\textit{full ACID}>>).  Однако это не совсем так, потому что транзакции, поддерживающие \textbf{изоляцию моментальных снимков} не являются полностью изолированными. 
\par
То есть, полученные  истории, по-видимому, не нарушают \textbf{изоляцию моментальных снимков}, но, тем не менее, демонстрируют циклические зависимости транзакций.
\par
Можно ли говорить, что эти истории удовлетворяют требованиям <<\textit{full ACID}>>? Возможно, но если это так, тогда из этого следует, что <<\textbf{I}>> в \textit{ACID} означает только частичную изоляцию, или <<\textit{full}>> означает несколько меньше, чем полная.
\par
Данная аномалия не редкость. Примерно в 15\% транзакций наблюдались аномалии во время нормальной работы, без сбоев.


\chapter{Выводы}
В данной работе был обозначен ряд проблем, которые возникают в распределенных системах. Зачастую они носят случайный характер. Также их сложно выявить на этапе разработки распределенной системы.  Это обуславливает необходимость введения формальных определений различных моделей согласованности.
\par Также сложность обнаружения различных нарушений изоляции и согласованности обуславливает появление Jepsen как инструмента для проверки гарантий выполнения важнейших свойств распределенных систем. Этот инструмент был представлен в данной работе.
\par Кроме того, в этой работе с помощью Jepsen была проанализирована реальная база данных --- Cosmos DB.  Cosmos DB утверждает, что поддерживает  <<полностью ACID транзакции>> через изоляцию моментальных снимков. Однако использование этих транзакций осложняется запутанной документацией и API.  А также изоляция моментальных снимков плохо совместима с маркетинговой фразой <<\textit{full ACID}>>.  В процессе тестирования наблюдались истории, которые казались совместимыми с изоляцией моментальных снимков, но также включали аномалии G2-item (циклы анти зависимости), в которых транзакции не наблюдали эффектов друг друга.  Такие аномалии были замечены в 15\% историй. Это корректно при изоляции моментальных снимков, но спорно, что эти транзакции являются полностью изолированными  в смысле \textit{ACID}.
\par Итак, в этой работе было проведено лишь краткое исследование. В дальнейшем в рамках развития данной работы возможно реализовать другие тесты, например, \textit{register} тест, а также исследовать поведение базы данных при различных сбоях.


\bibliographystyle{unsrt}
\bibliography{references}


\end{document}
