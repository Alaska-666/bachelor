\documentclass[12pt,  openany]{book}
\pagestyle{plain}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{extsizes}
\usepackage[english,russian]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyphsubst}
\usepackage{tempora}
\usepackage{amsmath}
\usepackage[nottoc,notlot,notlof,numbib]{tocbibind}
\usepackage{natbib}
\usepackage{indentfirst}
\usepackage{titlesec}
\titleformat{\chapter}[display]
  {\normalfont\bfseries}{}{0pt}{\Huge}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.98,0.98,0.98}

\lstdefinestyle{mystyle}{
    frame=single,
    aboveskip=5mm,
    belowskip=5mm,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\small\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=7pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
  
\geometry{
    a4paper,
    left=30mm,
    top=20mm,
    right=15mm,
    bottom=20mm
}
\linespread{1.5}

\title{Проверка консистентности и изоляции транзакций в распределенных системах}
\author{Исаева Анна}
\date{2021}
\setlength{\parindent}{1.25cm}

\begin{document}
\maketitle
\chapter*{Аннотация}
\par
аннотация \newline
объем аннотации <  1500 символов,  отразить цели и задачи работы, полученные результаты, рекомендации, предложенные на основании данной работы
\setcounter{page}{2}
\tableofcontents
\clearpage



\chapter{Введение}

Существует спрос на инструменты проверки изоляции транзакций, так  как базы данных не обеспечивают тот уровень изоляции, на который претендуют.  Почему? Чем они могут быть полезны?
\begin{itemize}
\item Пользователю(разработчику приложения, хранящего свои данные в базе данных) хочется научиться понимать про ту или иную базу данных, насколько она соответствует документации (это необходимо для того, чтобы выбрать базу, максимально удовлетворяющую потребностям пользователя);
\item Удобный инструмент для тестирования согласованности может существенно помочь на этапе разработки распределенных систем, возможно, стать одним из этапов CI/CD процесса;
\item Jepsen проводит свои исследования независимо и в соответствии с их этической политикой. Это вносит большой вклад в сообщество, помогает в развитии и совершенствовании распределенных систем.
\end{itemize}
Большинство распределенных систем стремятся к достижению баланса между временем выполнения операций и согласованностью.  Один из инструментов для проверки гарантии согласованности - это инструмент хаос-тестирования Jepsen.  Хаос-тестирование ---  это тестирование путем внесения в систему незапланированных сбоев \cite{chaosTesting}.  Наблюдая за поведением системы, можно понять, как сделать распределенную систему более надежной. Хаос тестирование это важная часть тестирования, потому что помогает выявить состояния гонки (race condition), которые сложно иначе обнаружить в процессе разработки.

\section{Цели работы}
\begin{itemize}
  \item Получить опыт работы с выбранным инструментом проверки свойств транзакций (Jepsen);
  \item Изучить выполненные данным инструментом исследования различных баз данных;
  \item Исследовать с помощью выбранного инструмента реальную базу данных (Azure Cosmos DB), которая еще не была проанализирована;
  \item Сравнить уровень согласованности, заявленный в документации, и уровень, установленный с помощью тестов.
\end{itemize}

\section{Основные понятия}
Введем основные понятия,  необходимые в дальнейшем.

\emph{Распределенная система} ---  

\emph{Хаос-тестирование \cite{chaosTesting}} ---  это тестирование путем внесения в распределенную систему незапланированных сбоев.

\emph{Процесс} ---  

\emph{Операция} --- переход из одного состояние в другое. 

\emph{Атомарная операция} --- операция в общей области памяти, которая завершается за один шаг относительно других потоков, имеющих доступ к этой области памяти.  Во время выполнения такой операции над переменной ни один поток не может наблюдать изменение наполовину завершенным. Неатомарные операции не дают такой гарантии.

\emph{Параллелизм} ---  

\emph{Сбой} ---  

\emph{История} ---  

\emph{Модель согласованности} --- набор гарантий о предсказуемости результатов операций чтения,  записи и изменения данных,  позволяющий рассуждать о поведении компьютерной программы.

\emph{Транзакция} ---  

\emph{Happens-before} ---  

\section{План работы}
В \textit{Главе 2} будут рассмотрена основная информация о базах данных и о моделях согласованности для них. А также будут рассмотрены проблемы, которые могут возникать в процессе эксплуатации распределенных систем.
\par
В \textit{Главе 3} будет представлен анализ инструмента Jepsen для тестирования согласованности распределенных систем. Также будет проведен обзор исследований разных баз данных, выполненный с помощью Jepsen. Кроме того, будет рассмотрен инструмент Jepsen, который позволяет выявить аномалии в транзакционных историях (Elle).Этот инструмент для проверки транзакционных историй будет использован в дальнейшем в нашем эксперименте.
 \par
\textit{Глава 4} включит в себя подробное описание базы данных Azure Cosmos DB. Будет описан эксперимент,который был проведен над ней, чтобы выяснить,какие гарантии согласованности предоставлены и соответствуют ли они документации.

\chapter{Синхронизация в базах данных}
\section{Базы данных}
\section{Модели согласованности \cite{jepsenConsistencyModels}}
\subsection{Отношения между моделями согласованности}
\includegraphics[scale=0.5]{model-consistency.png}
\subsection{Строгая сериализуемость (англ.  \textit{Strict Serializability})}
Строгая сериализуемость это  модель, которая означает, что операции произошли в некотором порядке, совместимом с порядком этих операций в реальном времени. Например, если операция А завершается до начала операции В, это означает, что А предшествует В в порядке сериализации.
\par
Итак, строгая сериализуемость гарантирует, что операции выполняются атомарно, то есть подоперации из одной транзакции не чередуются с подоперациями другой транзакции.
Строгая сериализуемость не может гарантировать полной или частичной доступности. Это означает, что в случае разрыва в сети некоторые или все узлы в сети не смогут добиться прогресса.
Строгая сериализуемость подразумевает сериализуемость и линеаризуемость. Вы можете думать о строгой сериализуемости как об общем порядке сериализуемости транзакционных многообъектных операций плюс ограничения линеаризуемости в реальном времени. В качестве альтернативы можно представить строгую сериализованную базу данных как линеаризованный объект, в котором состояние объекта - это вся база данных.
Ограничение линеаризуемости в реальном времени: транзакция A предшествует транзакции B, если A завершается до начала B.

\subsection{Сериализуемость(англ.  \textit{Serializability})}
Сериализуемость - это транзакционная модель, в которой операции(транзакции) могут включать в себя несколько примитивных подопераций, выполняемых по порядку. Сериализуемость гарантирует, что операции выполняются атомарно: подоперации транзакции не чередуются с подоперациями из других транзакций.
\par
Неформально сериализуемость означает, что транзакции произошли в некотором общем порядке.
Это мульти объектное свойство: операции могут действовать на несколько объектов в системе, и к системе в целом.
Сериализуемость не дает гарантии доступности.
Сериализуемость подразумевает "повторяемое чтение", "изоляцию моментальных снимков" и т. д. Однако она не накладывает никаких ограничений в реальном времени (здесь и далее это означает, что если процесс A завершает запись w, то процесс B начинает чтение r, не гарантируется, что r наблюдает w).
Кроме того, процесс может наблюдать запись, а затем не наблюдать эту же запись в последующей транзакции. Фактически, процесс может не наблюдать свои собственные предыдущие записи, если эти записи происходили в разных транзакциях.
\par
Более формально, сериализуемое выполнение определяется как одновременное выполнение операций SQL-транзакций, которое производит тот же эффект, что и некоторое последовательное выполнение тех же SQL-транзакций. Последовательное выполнение - это такое выполнение, при котором каждая SQL-транзакция выполняется полностью до начала следующей SQL-транзакции.
Также можно говорить, что сериализуемость это read committed (чтение фиксированных данных), но с дополнительным ограничением на фантомное чтение.
В другой формулировке сериализуемость определяется как отсутствие 4 явлений:
\begin{itemize}
  \item грязной записи,
  \item грязного чтения,
  \item неповторяющееся чтение,
  \item фантомное чтение.
\end{itemize}
Сериализуемость это также комбинация трех свойств:
Внутренняя согласованность (здесь и далее это означает, что в рамках транзакции чтения наблюдают за последними записями этой транзакции (если таковые имеются)).
Внешняя согласованность (здесь и далее: чтение без предшествующей записи в транзакции T1 должно учитывать состояние, записанное транзакцией T0, так что T0 виден T1, и никакая более поздняя транзакция не записана в этот объект).
Полная видимость: отношение видимости должно быть полным порядком.

\subsection{Повторяемое чтение(англ.  \textit{Repeatable Read })}
Эта модель согласованности тесно связана с сериализуемостью, но допускает фантомное чтение.
Повторяемое чтение-это транзакционная модель(здесь и далее это означает, что операции (транзакции) могут включать в себя несколько примитивных подопераций, выполняемых по порядку). Это также мульти объектное свойство(здесь и далее это означает. что операции могут действовать на несколько объектов в системе).
Нет гарантии полной доступности.
Повторяемое чтение включает в себя стабильность курсора, чтение фиксированных данных и т.д.
Также повторяемое чтение не накладывает никаких ограничений в реальном времени.
Повторяемое чтение не требует упорядочивания процессов между транзакциями (здесь и далее это означает, что процесс может наблюдать запись, а затем не наблюдать эту же запись в последующей транзакции. Фактически, процесс может не наблюдать свои собственные предыдущие записи, если эти записи происходили в разных транзакциях).
Можно определять повторяемое чтение как  read committed (чтение фиксированных данных), но с дополнительным ограничением на неповторяющееся чтение.
Иными словами, для повторяемого чтения запрещены: грязная запись, грязное чтение, неповторяющееся чтение, но допускается фантомное чтение. 

\subsection{Изоляция моментальных снимков(англ.  \textit{Snapshot Isolation})}
Изменения транзакции видны только этой транзакции до момента фиксации, когда все изменения становятся видимыми атомарно. Если транзакция T1 изменила объект x, а другая транзакция T2 совершила запись в x после начала моментального снимка T1 и до фиксации T1, то T1 должна прерваться.
Изоляция моментальных снимков - это транзакционная модель. Это также мульти объектное свойство.
Нет гарантии полной доступности. 
В отличие от сериализуемости, которая обеспечивает полный порядок транзакций, изоляция моментальных снимков вызывает только частичный порядок: подоперации в одной транзакции могут чередоваться с подоперациями из других транзакций. Наиболее заметными явлениями, допускаемыми изоляцией моментальных снимков, являются перекосы записи, которые позволяют транзакциям считывать перекрывающееся состояние, изменять непересекающиеся наборы объектов, а затем фиксировать; и аномалия транзакций только для чтения, включающая частично непересекающиеся наборы записи.
Изоляция моментальных снимков подразумевает read commited (чтение фиксированны данных). Однако не накладывается никаких ограничений в реальном времени и не требует упорядочивания процессов между транзакциями.
В терминах абстрактного алгоритма можно говорить о данной модели согласованности так: каждая транзакция считывает данные из моментального снимка зафиксированных данных на момент начала транзакции, называемого ее меткой начала отсчета. Это время может быть в любое время до первого чтения транзакции. Транзакция никогда не блокируется при попытке чтения до тех пор, пока данные моментального снимка из его метки начала отсчета могут быть сохранены. Записи транзакции (обновления, вставки и удаления) также будут отражены в этом моментальном снимке, чтобы быть прочитанными снова, если транзакция обращается к данным во второй раз. Обновления другими транзакциями, активными после метки начала отсчета транзакции, невидимы для транзакции. 
Когда транзакция T1 готова к фиксации, она получает метку времени фиксации, которая больше любой существующей метки начала отсчета или другой метки времени фиксации. Транзакция успешно фиксируется только в том случае, если ни одна другая транзакция T2 с меткой времени фиксации в интервале выполнения T1 [время начала отсчета, время фиксации] не записала данные, которые также записал T1. В противном случае T1 прервется. Это предотвращает потерю обновлений. Когда T1 фиксирует, его изменения становятся видимыми для всех транзакций, метки начала отсчета которых больше, чем метка времени фиксации T1.
В другой формулировке изоляции моментальных снимков определяется как комбинация четырех свойств:
\begin{itemize}
\item внутренняя согласованность
\item внешняя согласованность
\item Префикс: транзакции становятся видимыми для всех узлов в одном и том же порядке
\item Отсутствие конфликта: если две транзакции записываются в один и тот же объект, одна должна быть видна другой.
\end{itemize}

\subsection{Стабильность курсора(англ.  \textit{Cursor Stability})}
Стабильность курсора - это модель согласованности, которая усиливает read committed(чтение фиксированных данных), предотвращая потерю обновлений.
Введем понятие курсора, который относится к определенному объекту, доступ к которому осуществляется транзакцией. Транзакции могут иметь несколько курсоров. Когда транзакция считывает объект с помощью курсора, этот объект не может быть изменен какой-либо другой транзакцией до тех пор, пока курсор не будет отпущен или транзакция не будет зафиксирована.
Это предотвращает потерю обновлений, когда транзакция T1 считывает, изменяет и записывает обратно объект x, но другая транзакция T2 также обновляет x после того, как T1 прочитал x, что приводит к фактической потере обновления T2.
Стабильность курсора - это транзакционная модель. Это также мульти объектное свойство.
Нет гарантии полной доступности.
Стабильность курсора не требует упорядочивания процессов между транзакциями.
Не накладывает никаких ограничений в реальном времени.
Так как стабильность курсора это более строгое требование, чем read committed, также запрещены грязное чтение и грязная запись, но допустимо неповторяющееся чтение и фантомное чтение.

Формализация Адьи определяет этот уровень изоляции как два запрещенных явления: G-cursor и G1.

\subsection{Монотонное атомарное представление(англ.  \textit{Monotonic Atomic View})}
Монотонное атомарное представление - это модель согласованности, которая усиливает read committed, препятствуя транзакциям наблюдать некоторые, но не все, эффекты ранее зафиксированной транзакции. Он выражает атомарное ограничение ACID, что все (или ни один) эффекты транзакции должны иметь место. Как только запись из транзакции T1 наблюдается транзакцией T2, то все эффекты T1 должны быть видны T2. 
Есть гарантия полной доступности.
Монотонное атомарное представление не требует упорядочивания процессов между транзакциями. Не накладывает никаких ограничений в реальном времени.
Монотонное атомарное представление сильнее, чем  read committed, поэтому также запрещены грязное чтение и грязная запись, но допустимо неповторяющееся чтение и фантомное чтение.
Как только некоторые эффекты транзакции Ti наблюдаются другой транзакцией Tj, после этого все эффекты Ti наблюдаются Tj. То есть, если транзакция Tj считывает версию объекта, записанную транзакцией Ti, то более позднее чтение Tj не может вернуть значение, более поздняя версия которого установлена Ti.
С точки зрения формализации Адьи монотонное атомарное представление запрещает G1b (промежуточное чтение).

\subsection{Чтение фиксированных данных(англ.  \textit{Read Committed})}
Модель согласованности, которая усиливает read uncommitted, предотвращая “грязное чтение” (транзакциям запрещено наблюдать за записями других транзакций, которые не фиксируются). Тем не менее, в процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы. В итоге первая транзакция будет работать с другим набором данных.

Это транзакционная модель: операции (обычно называемые «транзакциями») могут включать несколько примитивных подопераций, выполняемых по порядку. Это также multi-object свойство: операции могут действовать на несколько объектов в системе.

Read Committed не требует отдельного процесса между транзакциями. Процесс может наблюдать запись, а затем не наблюдать эту же запись в последующей транзакции. Фактически, процесс может не отслеживать свои предыдущие записи, если эти записи происходили в разных транзакциях.
Реализация Read Committed может основываться на одном из двух подходов: блокировании или версионности.

\subsection{Чтение незафиксированных данных(англ.  \textit{Read Uncommitted})}
Модель согласованности, которая запрещает “грязную” запись, когда две транзакции одновременно изменяют один и тот же объект перед фиксацией. Зато позволяет другие аномалии (грязное чтение, фантомное чтение, неповторяющееся чтение). 
\par
Это транзакционная модель: операции (обычно называемые «транзакциями») могут включать несколько примитивных под операций, выполняемых по порядку. Это также multi-object свойство: операции могут действовать на несколько объектов в системе.
\par
Модель гарантирует отсутствие потерянных обновлений. Если несколько параллельных транзакций пытаются изменять одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение, определенное всем набором успешно выполненных транзакций. При этом возможно считывание не только логически несогласованных данных, но и данных, изменения которых еще не зафиксированы.
Типичный способ реализации данного уровня изоляции — блокировка данных на время выполнения команды изменения, что гарантирует, что команды изменения одних и тех же строк, запущенные параллельно, фактически выполняются последовательно, и ни одно из изменений не потеряется. Транзакции, выполняющие только чтение, при данном уровне изоляции никогда не блокируются.

\subsection{Линеаризуемость(англ.  \textit{Linearizability})}
Линеаризуемость - это одна из самых сильных моделей однообъектной согласованности и подразумевает, что каждая операция выполняется атомарно, в некотором порядке, совместимом с порядком этих операций в реальном времени. 
Нет гарантии какой-либо доступности.
Линеаризуемость-это однообъектная модель, но объем “объекта” варьируется. Некоторые системы обеспечивают линеаризуемость отдельных ключей в хранилище ключ-значение; другие могут обеспечивать линеаризуемость операций над несколькими ключами в таблице или несколькими таблицами в базе данных, но не между различными таблицами или базами данных соответственно.
Более формально, история исполнения H такова, что существует эквивалентная последовательная история S, а частичный порядок операций в реальном времени в H согласуется с общим порядком S и сохраняет однопоточную семантику объектов.
Иными словами, должны выполняться сразу три свойства: \newline
1) единый порядок (существует некоторый общий порядок операций); \newline
2) привязка к реальному времени; \newline
3) подчинение однопоточным законам типа данных связанного объекта.

\subsection{Последовательная согласованность(англ.  \textit{Sequential Consistency })}
Это сильное свойство безопасности для параллельных систем. Неформально последовательная согласованность подразумевает, что операции происходят в некотором общем порядке и что этот порядок согласуется с порядком операций на каждом отдельном процессе.
Не гарантируется полная или частичная доступность.
Процесс в последовательно согласованной системе может быть далеко впереди или позади других процессов. Например, может быть прочитано устаревшее состояние. Однако, как только процесс A наблюдает некоторую операцию из процесса B, он никогда не может наблюдать состояние, предшествующее B.
Можно представить последовательную согласованность как три свойства: единый порядок (существует некоторый общий порядок операций), PRAM и порядок должен соответствовать семантике типа данных.
Более формально, когда мы говорим о последовательной согласованности, считается, что результат любого исполнения такой же, как если бы операции всех процессоров выполнялись в некотором последовательном порядке, и операции каждого отдельного процессора отображаются в этой последовательности в порядке, определенном его программой.

\subsection{Причинная согласованность(англ.  \textit{Causal Consistency})}
Это модель согласованности говорит о том, что причинно-связанные операции должны появляться в одном и том же порядке во всех процессах, хотя порядок может меняться для причинно-независимых операций.
Гарантируется частичная доступность.
\par
Причинная память проистекает из определения отношения "происходит до"(happens-before), которое фиксирует понятие потенциальной причинности, связывая операцию с предыдущими операциями того же процесса и с операциями над другими процессами, последствия которых могли быть видны благодаря сообщениям, которыми обменивались эти процессы.
\textit{Happens before} \newline
Пусть есть поток X и поток Y (не обязательно отличающийся от потока X). И пусть есть операции A (выполняющаяся в потоке X) и B (выполняющаяся в потоке Y).
\par
В таком случае, A happens-before B означает, что все изменения, выполненные потоком X до момента операции A и изменения, которые повлекла эта операция, видны потоку Y в момент выполнения операции B и после выполнения этой операции.

\subsection{Записи следуют за чтениями(англ.  \textit{Writes Follow Reads })}
Данная модель согласованности гарантирует, что если процесс считывает значение v, которое пришло из записи w1, а затем выполняет запись w2, то запись w2 должна быть видна после w1. Как только вы что-то прочитали, вы не можете изменить прошлое этого чтения. Гарантируется полная доступность.

\subsection{Конвейерная Оперативная Память(англ.  \textit{PRAM, Pipeline Random Access Memory})}
PRAM пытается ослабить существующие когерентные модели памяти, чтобы получить лучший параллелизм (и, следовательно, производительность). Эта модель гарантирует, что любая пара записей, выполненных одним процессом, наблюдалась везде в том порядке, в котором процесс их выполнил; однако записи из разных процессов могут наблюдаться в разных порядках. 
\par
PRAM эквивалентен монотонному чтению, монотонной записи и чтению своих записей (смотреть далее).
Гарантируется частичная доступность.
Более формально, ПРАМ удовлетворяется, если порядок сеанса (порядок операций над каждым процессом) является подмножеством порядка видимости (какие операции видны данной операции).

\subsection{Монотонные чтения(англ.  \textit{Monotonic Reads})}
Эта модель согласованности гарантирует, что если процесс выполняет чтение r1, а затем r2, то r2 не может наблюдать состояние до записи, которая была отражена в r1.
Не применяется к операциям, выполняемым различными процессами, а только к операциям, выполняемым одним и тем же процессом.
Монотонное чтение может быть полностью доступно (все узлы могут совершать прогресс даже во время разрыва в сети)
\par
Более формально, можно говорить о монотонном чтении в терминах порядка сеанса (порядка операций, выполняемых одним и тем же процессом) и порядка видимости (какие записи видны для каких чтений). Для всех операций a, b и c, где b и c являются чтением, если a виден b, и b выполняется до и тем же процессом, что и c, то a должен быть виден c.

\subsection{Монотонные записи(англ.  \textit{Monotonic Writes})}
Эта модель согласованности гарантирует, что если процесс выполняет запись w1,  а затем w2, то все процессы наблюдают w1 до w2. Не применяется к операциям, выполняемым различными процессами, а только к  операциям, выполняемым одним и тем же процессом.
Есть полная доступность: даже во время разрыва сети все узлы могут совершать прогресс.

\subsection{Чтение своих записей(англ.  \textit{Read Your Writes})}
Этот уровень изоляции транзакций требует: если процесс выполняет запись w, то этот же процесс выполняет последующее чтение r, и тогда r должен наблюдать эффекты w.
Важно, что это модель не применяется к операциям, выполняемым различными процессами. Например, нет никакой гарантии, что если процесс 1 успешно запишет значение, то процесс 2 впоследствии будет наблюдать эту запись.
\par
Есть гарантия частичной доступности: если возникает разрыв сети, каждый узел может добиться прогресса (если клиент никогда не меняет сервер, с которым он взаимодействует).
Более формально: для любой записи и любого чтения, если запись происходит прямо перед чтением в данном сеансе (процессе), то запись должна быть видна для чтения. Другими словами, порядок сеанса (ограниченный только записью -> чтением) является подмножеством порядка видимости.


\section{Нарушения согласованности}
... какие проблемы бывают с согласованностью
(только те, которые были упомянуты в секции выше)
\subsection{грязная запись}
\subsection{грязное чтение}
\subsection{неповторяющееся чтение}
\subsection{фантомное чтение}
\subsection{G-cursor}
G-cursor(x): граф направленной сериализации, ограниченный одним объектом x, содержит анти-зависимый цикл и по крайней мере одно ребро, зависимое от записи.

\subsection{G1}
G1: включает в себя три запряженных явления: \newline
G1a (прерванное чтение): транзакция наблюдает объект, измененный прерванной транзакцией  \newline
G1b (промежуточное чтение): транзакция наблюдает объект, измененный транзакцией, которая не была окончательной модификацией этого объекта этой транзакцией. Иными словами, транзакции должны завершиться, прежде чем мы сможем их прочитать,  \newline
G1c (циклический информационный поток): направленный граф сериализации транзакций содержит направленный цикл, полностью состоящий из ребер зависимостей. Иными словами, что если транзакция T1 подвержена влиянию T2, то T2 не может быть подвержена влиянию T1.

\chapter{Методология проверки согласованности распределенных систем}
\section{Jepsen}
\section{Обзор исследований, выполненных Jepsen}
Jepsen использовался для тестирования многих распределенных систем. 
Я ознакомилась с результатами некоторых из них.
\subsection{Etcd 3.4.3 \cite{etcdAnalyses} \cite{etcdTutorial}}
\subsection{MongoDB 4.2.6}
\subsection{PostgreSQL 12.3}

\chapter{Исследование согласованности Azure Cosmos DB}
\section{Azure Cosmos DB}

\section{Уровни согласованности}
Azure Cosmos DB предоставляет 5 уровней согласованности \cite{cosmosConsistencyLevels}.
\subsection{strong}
Данные синхронно реплицируются на все реплики в режиме реального времени. Гарантирует линеаризацию. Это означает, что порядок операций сохраняется, и считывания гарантированно возвращают самую последнюю версию элемента в базе данных. Клиент всегда получает последние изменения в данных по запросу. Никогда не будет видима незафиксированная или частично измененная запись. Самая низкая производительность и доступность.
\subsection{bounded staleness}
Данные реплицируются асинхронно с заданным окном устаревания, определяемым либо количеством записей, либо периодом времени. Запрос на чтение может отставать либо на определенное количество операций записи, либо на заранее определенный период времени. Однако при чтении гарантируется соблюдение последовательности данных. По мере приближения окна устаревания репликация данных запускается в учетной записи базы данных, заставляющей базу данных обновлять новые записи с момента последнего изменения. Низкая доступность из-за задержки синхронизации разных регионов. Более хорошая производительность.
\subsection{session}
Это уровень согласованности по умолчанию. Это обеспечивает сильную согласованность для сеанса приложения с одним и тем же токеном сеанса. Это означает, что все, что написано сеансом, также вернет последнюю версию для чтения из того же сеанса. Доступность данных относительно высока и более низкой задержкой и более высокой пропускной способностью, чем bounded staleness. Данные из других сеансов поступают в правильном порядке, просто не гарантируется, что они будут актуальными.
\subsection{consistent prefix}
Эта модель согласованности аналогична bounded staleness, только без гарантии задержки. Реплики гарантируют согласованность и порядок записи, однако данные не всегда актуальны. Эта модель гарантирует, что пользователь никогда не увидит неупорядоченную запись. Высокая доступность и низкая задержка.
\subsection{eventual}
Для операции чтения нет гарантии порядка данных, а также отсутствует гарантия того, сколько времени может потребоваться для репликации данных.  Это слабая форма согласованности, так как могут быть считаны более старые значения чем те, которые были считаны раньше.
Высокая доступность, самая высокая пропускная способность и низкая задержка.

\chapter{Заключение}
Выводы

\bibliographystyle{unsrt}
\bibliography{references}

\chapter{Приложения}


\end{document}
