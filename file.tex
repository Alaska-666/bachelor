\documentclass[12pt,  openany]{book}
\pagestyle{plain}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{extsizes}
\usepackage[english,russian]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyphsubst}
\usepackage{svg}
\usepackage{tempora}
\usepackage{amsmath}
\usepackage{relsize}
\usepackage{listings}
\usepackage[nottoc,notlot,notlof,numbib]{tocbibind}
\usepackage{natbib}
\usepackage{indentfirst}
\usepackage{titlesec}
\titleformat{\chapter}[display]
  {\normalfont\bfseries}{}{0pt}{\Huge}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.98,0.98,0.98}

\lstdefinestyle{mystyle}{
    frame=single,
    aboveskip=5mm,
    belowskip=5mm,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\small\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=7pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
  
\geometry{
    a4paper,
    left=30mm,
    top=20mm,
    right=15mm,
    bottom=20mm
}
\linespread{1.5}
\setlength{\parindent}{1.25cm}

\begin{document}
\chapter{Аннотация}
В современном мире очень много информации. И если Вы разрабатываете любое приложение, рано или поздно перед Вами встает вопрос - как и где хранить информацию ваших пользователей и вашего приложения. Здесь Вам на помощью приходит огромное количество уже существующих баз данных. И зачастую данных бывает настолько много, что неоправданно хранить их на одном компьютере. Тогда Вы используете распределенную базу данных. К современным распределенным базам данных предъявляется ряд требований. Одно из таких требований - согласованность данных в каждый момент времени. 
\par
Конечно же, разработчиков распределенных систем интересует вопрос: как быстро и легко тестировать согласованность системы? И как же удостовериться в том, что реализация транзакции (наш основной инструмент работы  с данными) удовлетворяет своим основным свойствам? 
\par
Один из инструментов для проверки гарантий согласованности, который практически не имеет аналогов, это инструмент хаос-тестирования Jepsen. 
\par
В этой работе мы  узнаем больше об уровнях согласованности распределенных систем. А также мы познакомимся с  Jepsen и принципами его работы. Кроме того, мы попробует самостоятельно проанализировать Azure Cosmos DB с помощью Jepsen. 

\setcounter{page}{2}
\tableofcontents
\clearpage



\chapter{Введение}

Существует спрос на инструменты проверки согласованности транзакций, так  как базы данных не обеспечивают тот уровень согласованности, на который претендуют.  Почему? Чем они могут быть полезны?
\begin{itemize}
\item Пользователю(разработчику приложения, хранящего свои данные в базе данных) хочется научиться понимать про ту или иную базу данных, насколько она соответствует документации (это необходимо для того, чтобы выбрать базу, которая больше всего подходить для потребностей пользователя базы данных);
\item Удобный инструмент для тестирования согласованности может существенно помочь на этапе разработки распределенных систем, возможно, стать одним из этапов CI/CD процесса;
\item Jepsen проводит свои исследования независимо и в соответствии с их этической политикой. Это вносит большой вклад в сообщество, помогает в развитии и совершенствовании распределенных систем.
\end{itemize}
Большинство распределенных систем стремятся к достижению баланса между временем выполнения операций и согласованностью.  Один из инструментов для проверки гарантии согласованности - это инструмент хаос-тестирования Jepsen.  Хаос-тестирование ---  это тестирование путем внесения в систему незапланированных сбоев \cite{chaosTesting}.  Наблюдая за поведением системы, можно понять, как сделать распределенную систему более надежной. Хаос тестирование это важная часть тестирования, потому что помогает выявить состояния гонки (race condition), которые сложно иначе обнаружить в процессе разработки.

\section{Цели работы}
\begin{itemize}
  \item Получить опыт работы с выбранным инструментом проверки свойств транзакций (Jepsen);
  \item Изучить выполненные данным инструментом исследования различных баз данных;
  \item Исследовать с помощью выбранного инструмента реальную базу данных (Azure Cosmos DB), которая еще не была проанализирована;
  \item Сравнить уровень согласованности, заявленный в документации, и уровень, установленный с помощью тестов.
\end{itemize}

\section{Основные понятия}
Введем основные понятия,  необходимые в дальнейшем.

\emph{Параллельная система} ---  это система, состоящая из независимых компонент, которые могут выполнять некоторые операции одновременно.

\emph{Распределенная система} ---  это тип параллельных систем, который представляет собой систему с несколькими независимыми компонентами, которые расположены на разных узлах в компьютерной сети.  Эти узлы способны обмениваться данными, а также они кооридинируют свои действия так, чтобы для конечного пользователя распределенная система работала как единая согласованная система.  Система имеет логическое стостояние, которое меняется с течением времени. 

\emph{Хаос-тестирование \cite{chaosTesting}} ---  это тестирование путем внесения в распределенную систему незапланированных сбоев.

\emph{Процесс} ---  это логически однопоточная программа, которая способна выполнять некоторые операции. 

\emph{Операция} --- переход из одного состояние в другое. 

\emph{Атомарная операция \cite{habrAtomicOperation}} --- операция в общей области памяти, которая завершается за один шаг относительно других потоков, имеющих доступ к этой области памяти.  Во время выполнения такой операции над переменной ни один поток не может наблюдать изменение наполовину завершенным. Неатомарные операции не дают такой гарантии.

\emph{Параллелизм} ---  это свойство системы, которое означает, что несколько процессов могут выполняться в одно и то же время. 

\emph{Сбой} ---  это состояние процесса, в котором тот не может вызывать никаких операций.Если операция по какой-то причине не была завершена и не имеет времени завершения, то ее следует рассматривать одновременно с каждой операцией, которая будет вызвана после.Это нарушает требования на однопоточность процесса,поэтому мы говорим о состоянии сбоя процесса.

\emph{История} ---  совокупность операций и их параллельной структуры.  В этой работе мы будем рассматривать историю с точки зрения  Jepsen. То есть история будет представлена в виде упорядоченного списка операций вызова и завершения.

\emph{Модель согласованности} --- набор гарантий, используемый в той или иной распределенной системе,  для обеспечения согласованности данных.

\emph{Транзакция} ---  некоторый конечный набор операций, переводящий данные из одного согласованного состояния в другое. Либо будет выполнена каждая операция из набора, либо ни одной. Основные свойства транзакций - атомарность, согласованность, изолированность и прочность (ACID).


\section{План работы}
В \textit{Главе 2} будут рассмотрена основная информация о базах данных и о моделях согласованности для них. А также будут рассмотрены проблемы, которые могут возникать в процессе эксплуатации распределенных систем.
\par
В \textit{Главе 3} будет представлен анализ инструмента Jepsen для тестирования согласованности распределенных систем. Также будет проведен обзор исследований разных баз данных, выполненный с помощью Jepsen. Кроме того, будет рассмотрен инструмент Jepsen, который позволяет выявить аномалии в транзакционных историях (Elle).Этот инструмент для проверки транзакционных историй будет использован в дальнейшем в нашем эксперименте.
 \par
\textit{Глава 4} включит в себя подробное описание базы данных Azure Cosmos DB. Будет описан эксперимент,который был проведен над ней, чтобы выяснить,какие гарантии согласованности предоставлены и соответствуют ли они документации.

\chapter{Синхронизация в базах данных}
\section{Базы данных}
База данных это некоторое хранилище данных.  Чаще всего в данной работе мы будем говорить о распределенных базах данных, то есть таких базах данных, составные части которых могут размещаться на различных узлах в компьютерной сети.
Основное требование к базам данных - это поддерживание какого-то внутреннего консистентного состояния данных. Иными словами, согласованность и целостность, непротиворечивость данных в каждый момент времени.
Различные базы данных добиваются этого разными способами. Реляционные базы данных предоставляют механизм транзакций, который гарантирует согласованность данных.
Чтобы ускорить работу с данными, базы данных используют некоторый механизм блокировок, который теоретически гарантирует консистентное состояние.Однако, как мы увидим далее, это не всегда правда.
\par
Некоторые базы данных реализуют различные модели согласованности,позволяющие регулировать гарантии, предоставляемые базой данных. Рассмотрим наиболее часто встречаемые модели согласованности, реализуемые базами данных.
\section{Модели согласованности \cite{jepsenConsistencyModels}}
\subsection{Отношения между моделями согласованности}
\includegraphics[scale=0.5]{model-consistency.png}
\subsection{Строгая сериализуемость (англ.  \textit{Strict Serializability})}
Строгая сериализуемость это  модель, которая означает, что операции произошли в некотором порядке, совместимом с порядком этих операций в реальном времени. Например, если операция А завершается до начала операции В, это означает, что А предшествует В в порядке сериализации.
\par
Итак, строгая сериализуемость гарантирует, что операции выполняются атомарно, то есть подоперации из одной транзакции не чередуются с подоперациями другой транзакции.
Строгая сериализуемость не может гарантировать полной или частичной доступности. Это означает, что в случае разрыва в сети некоторые или все узлы в сети не смогут добиться прогресса.
Строгая сериализуемость подразумевает сериализуемость и линеаризуемость. Вы можете думать о строгой сериализуемости как об общем порядке сериализуемости транзакционных многообъектных операций плюс ограничения линеаризуемости в реальном времени. В качестве альтернативы можно представить строгую сериализованную базу данных как линеаризованный объект, в котором состояние объекта - это вся база данных.
Ограничение линеаризуемости в реальном времени: транзакция A предшествует транзакции B, если A завершается до начала B.

\subsection{Сериализуемость(англ.  \textit{Serializability})}
Сериализуемость - это транзакционная модель, в которой операции(транзакции) могут включать в себя несколько примитивных подопераций, выполняемых по порядку. Сериализуемость гарантирует, что операции выполняются атомарно: подоперации транзакции не чередуются с подоперациями из других транзакций.
\par
Неформально сериализуемость означает, что транзакции произошли в некотором общем порядке.
Это мульти объектное свойство: операции могут действовать на несколько объектов в системе, и к системе в целом.
Сериализуемость не дает гарантии доступности.
Сериализуемость подразумевает "повторяемое чтение", "изоляцию моментальных снимков" и т. д. Однако она не накладывает никаких ограничений в реальном времени (здесь и далее это означает, что если процесс A завершает запись w, то процесс B начинает чтение r, не гарантируется, что r наблюдает w).
Кроме того, процесс может наблюдать запись, а затем не наблюдать эту же запись в последующей транзакции. Фактически, процесс может не наблюдать свои собственные предыдущие записи, если эти записи происходили в разных транзакциях.
\par
Более формально, сериализуемое выполнение определяется как одновременное выполнение операций SQL-транзакций, которое производит тот же эффект, что и некоторое последовательное выполнение тех же SQL-транзакций. Последовательное выполнение - это такое выполнение, при котором каждая SQL-транзакция выполняется полностью до начала следующей SQL-транзакции.
Также можно говорить, что сериализуемость это read committed (чтение фиксированных данных), но с дополнительным ограничением на фантомное чтение.
В другой формулировке сериализуемость определяется как отсутствие 4 явлений:
\begin{itemize}
  \item грязной записи,
  \item грязного чтения,
  \item неповторяющееся чтение,
  \item фантомное чтение.
\end{itemize}
Сериализуемость это также комбинация трех свойств:
Внутренняя согласованность (здесь и далее это означает, что в рамках транзакции чтения наблюдают за последними записями этой транзакции (если таковые имеются)).
Внешняя согласованность (здесь и далее: чтение без предшествующей записи в транзакции T1 должно учитывать состояние, записанное транзакцией T0, так что T0 виден T1, и никакая более поздняя транзакция не записана в этот объект).
Полная видимость: отношение видимости должно быть полным порядком.

\subsection{Повторяемое чтение(англ.  \textit{Repeatable Read })}
Эта модель согласованности тесно связана с сериализуемостью, но допускает фантомное чтение.
Повторяемое чтение-это транзакционная модель(здесь и далее это означает, что операции (транзакции) могут включать в себя несколько примитивных подопераций, выполняемых по порядку). Это также мульти объектное свойство(здесь и далее это означает. что операции могут действовать на несколько объектов в системе).
Нет гарантии полной доступности.
Повторяемое чтение включает в себя стабильность курсора, чтение фиксированных данных и т.д.
Также повторяемое чтение не накладывает никаких ограничений в реальном времени.
Повторяемое чтение не требует упорядочивания процессов между транзакциями (здесь и далее это означает, что процесс может наблюдать запись, а затем не наблюдать эту же запись в последующей транзакции. Фактически, процесс может не наблюдать свои собственные предыдущие записи, если эти записи происходили в разных транзакциях).
Можно определять повторяемое чтение как  read committed (чтение фиксированных данных), но с дополнительным ограничением на неповторяющееся чтение.
Иными словами, для повторяемого чтения запрещены: грязная запись, грязное чтение, неповторяющееся чтение, но допускается фантомное чтение. 

\subsection{Изоляция моментальных снимков(англ.  \textit{Snapshot Isolation})}
Изменения транзакции видны только этой транзакции до момента фиксации, когда все изменения становятся видимыми атомарно. Если транзакция T1 изменила объект x, а другая транзакция T2 совершила запись в x после начала моментального снимка T1 и до фиксации T1, то T1 должна прерваться.
Изоляция моментальных снимков - это транзакционная модель. Это также мульти объектное свойство.
Нет гарантии полной доступности. 
В отличие от сериализуемости, которая обеспечивает полный порядок транзакций, изоляция моментальных снимков вызывает только частичный порядок: подоперации в одной транзакции могут чередоваться с подоперациями из других транзакций. Наиболее заметными явлениями, допускаемыми изоляцией моментальных снимков, являются перекосы записи, которые позволяют транзакциям считывать перекрывающееся состояние, изменять непересекающиеся наборы объектов, а затем фиксировать; и аномалия транзакций только для чтения, включающая частично непересекающиеся наборы записи.
Изоляция моментальных снимков подразумевает read commited (чтение фиксированны данных). Однако не накладывается никаких ограничений в реальном времени и не требует упорядочивания процессов между транзакциями.
\par
В терминах абстрактного алгоритма можно говорить о данной модели согласованности так: каждая транзакция считывает данные из моментального снимка зафиксированных данных на момент начала транзакции, называемого ее меткой начала отсчета. Это время может быть в любое время до первого чтения транзакции. Транзакция никогда не блокируется при попытке чтения до тех пор, пока данные моментального снимка из его метки начала отсчета могут быть сохранены. Записи транзакции (обновления, вставки и удаления) также будут отражены в этом моментальном снимке, чтобы быть прочитанными снова, если транзакция обращается к данным во второй раз. Обновления другими транзакциями, активными после метки начала отсчета транзакции, невидимы для транзакции. 
Когда транзакция T1 готова к фиксации, она получает метку времени фиксации, которая больше любой существующей метки начала отсчета или другой метки времени фиксации. Транзакция успешно фиксируется только в том случае, если ни одна другая транзакция T2 с меткой времени фиксации в интервале выполнения T1 [время начала отсчета, время фиксации] не записала данные, которые также записал T1. В противном случае T1 прервется. Это предотвращает потерю обновлений. Когда T1 фиксирует, его изменения становятся видимыми для всех транзакций, метки начала отсчета которых больше, чем метка времени фиксации T1.
В другой формулировке изоляции моментальных снимков определяется как комбинация четырех свойств:
\begin{itemize}
\item внутренняя согласованность
\item внешняя согласованность
\item Префикс: транзакции становятся видимыми для всех узлов в одном и том же порядке
\item Отсутствие конфликта: если две транзакции записываются в один и тот же объект, одна должна быть видна другой.
\end{itemize}

\subsection{Стабильность курсора(англ.  \textit{Cursor Stability})}
Стабильность курсора - это модель согласованности, которая усиливает read committed(чтение фиксированных данных), предотвращая потерю обновлений.
Введем понятие курсора, который относится к определенному объекту, доступ к которому осуществляется транзакцией. Транзакции могут иметь несколько курсоров. Когда транзакция считывает объект с помощью курсора, этот объект не может быть изменен какой-либо другой транзакцией до тех пор, пока курсор не будет отпущен или транзакция не будет зафиксирована.
Это предотвращает потерю обновлений, когда транзакция T1 считывает, изменяет и записывает обратно объект x, но другая транзакция T2 также обновляет x после того, как T1 прочитал x, что приводит к фактической потере обновления T2.
Стабильность курсора - это транзакционная модель. Это также мульти объектное свойство.
Нет гарантии полной доступности.
Стабильность курсора не требует упорядочивания процессов между транзакциями.
Не накладывает никаких ограничений в реальном времени.
Так как стабильность курсора это более строгое требование, чем read committed, также запрещены грязное чтение и грязная запись, но допустимо неповторяющееся чтение и фантомное чтение.

Формализация Адьи определяет этот уровень изоляции как два запрещенных явления: G-cursor и G1.

\subsection{Монотонное атомарное представление(англ.  \textit{Monotonic Atomic View})}
Монотонное атомарное представление - это модель согласованности, которая усиливает read committed, препятствуя транзакциям наблюдать некоторые, но не все, эффекты ранее зафиксированной транзакции. Он выражает атомарное ограничение ACID, что все (или ни один) эффекты транзакции должны иметь место. Как только запись из транзакции T1 наблюдается транзакцией T2, то все эффекты T1 должны быть видны T2. 
Есть гарантия полной доступности.
Монотонное атомарное представление не требует упорядочивания процессов между транзакциями. Не накладывает никаких ограничений в реальном времени.
Монотонное атомарное представление сильнее, чем  read committed, поэтому также запрещены грязное чтение и грязная запись, но допустимо неповторяющееся чтение и фантомное чтение.
Как только некоторые эффекты транзакции Ti наблюдаются другой транзакцией Tj, после этого все эффекты Ti наблюдаются Tj. То есть, если транзакция Tj считывает версию объекта, записанную транзакцией Ti, то более позднее чтение Tj не может вернуть значение, более поздняя версия которого установлена Ti.
С точки зрения формализации Адьи монотонное атомарное представление запрещает G1b (промежуточное чтение).

\subsection{Чтение фиксированных данных(англ.  \textit{Read Committed})}
Модель согласованности, которая усиливает read uncommitted, предотвращая “грязное чтение” (транзакциям запрещено наблюдать за записями других транзакций, которые не фиксируются). Тем не менее, в процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы. В итоге первая транзакция будет работать с другим набором данных.

Это транзакционная модель: операции (обычно называемые «транзакциями») могут включать несколько примитивных подопераций, выполняемых по порядку. Это также multi-object свойство: операции могут действовать на несколько объектов в системе.

Read Committed не требует отдельного процесса между транзакциями. Процесс может наблюдать запись, а затем не наблюдать эту же запись в последующей транзакции. Фактически, процесс может не отслеживать свои предыдущие записи, если эти записи происходили в разных транзакциях.
Реализация Read Committed может основываться на одном из двух подходов: блокировании или версионности.

\subsection{Чтение незафиксированных данных(англ.  \textit{Read Uncommitted})}
Модель согласованности, которая запрещает “грязную” запись, когда две транзакции одновременно изменяют один и тот же объект перед фиксацией. Зато позволяет другие аномалии (грязное чтение, фантомное чтение, неповторяющееся чтение). 
\par
Это транзакционная модель: операции (обычно называемые «транзакциями») могут включать несколько примитивных под операций, выполняемых по порядку. Это также multi-object свойство: операции могут действовать на несколько объектов в системе.
\par
Модель гарантирует отсутствие потерянных обновлений. Если несколько параллельных транзакций пытаются изменять одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение, определенное всем набором успешно выполненных транзакций. При этом возможно считывание не только логически несогласованных данных, но и данных, изменения которых еще не зафиксированы.
Типичный способ реализации данного уровня изоляции — блокировка данных на время выполнения команды изменения, что гарантирует, что команды изменения одних и тех же строк, запущенные параллельно, фактически выполняются последовательно, и ни одно из изменений не потеряется. Транзакции, выполняющие только чтение, при данном уровне изоляции никогда не блокируются.

\subsection{Линеаризуемость(англ.  \textit{Linearizability})}
Линеаризуемость - это одна из самых сильных моделей однообъектной согласованности и подразумевает, что каждая операция выполняется атомарно, в некотором порядке, совместимом с порядком этих операций в реальном времени. 
Нет гарантии какой-либо доступности.
Линеаризуемость-это однообъектная модель, но объем “объекта” варьируется. Некоторые системы обеспечивают линеаризуемость отдельных ключей в хранилище ключ-значение; другие могут обеспечивать линеаризуемость операций над несколькими ключами в таблице или несколькими таблицами в базе данных, но не между различными таблицами или базами данных соответственно.
Более формально, история исполнения H такова, что существует эквивалентная последовательная история S, а частичный порядок операций в реальном времени в H согласуется с общим порядком S и сохраняет однопоточную семантику объектов.
Иными словами, должны выполняться сразу три свойства: \newline
1) единый порядок (существует некоторый общий порядок операций); \newline
2) привязка к реальному времени; \newline
3) подчинение однопоточным законам типа данных связанного объекта.

\subsection{Последовательная согласованность(англ.  \textit{Sequential Consistency })}
Это сильное свойство безопасности для параллельных систем. Неформально последовательная согласованность подразумевает, что операции происходят в некотором общем порядке и что этот порядок согласуется с порядком операций на каждом отдельном процессе.
Не гарантируется полная или частичная доступность.
Процесс в последовательно согласованной системе может быть далеко впереди или позади других процессов. Например, может быть прочитано устаревшее состояние. Однако, как только процесс A наблюдает некоторую операцию из процесса B, он никогда не может наблюдать состояние, предшествующее B.
Можно представить последовательную согласованность как три свойства: единый порядок (существует некоторый общий порядок операций), PRAM и порядок должен соответствовать семантике типа данных.
Более формально, когда мы говорим о последовательной согласованности, считается, что результат любого исполнения такой же, как если бы операции всех процессоров выполнялись в некотором последовательном порядке, и операции каждого отдельного процессора отображаются в этой последовательности в порядке, определенном его программой.

\subsection{Причинная согласованность(англ.  \textit{Causal Consistency})}
Это модель согласованности говорит о том, что причинно-связанные операции должны появляться в одном и том же порядке во всех процессах, хотя порядок может меняться для причинно-независимых операций.
Гарантируется частичная доступность.
\par
Причинная память проистекает из определения отношения "происходит до"(happens-before), которое фиксирует понятие потенциальной причинности, связывая операцию с предыдущими операциями того же процесса и с операциями над другими процессами, последствия которых могли быть видны благодаря сообщениям, которыми обменивались эти процессы.
\textit{Happens before} \newline
Пусть есть поток X и поток Y (не обязательно отличающийся от потока X). И пусть есть операции A (выполняющаяся в потоке X) и B (выполняющаяся в потоке Y).
\par
В таком случае, A happens-before B означает, что все изменения, выполненные потоком X до момента операции A и изменения, которые повлекла эта операция, видны потоку Y в момент выполнения операции B и после выполнения этой операции.

\subsection{Записи следуют за чтениями(англ.  \textit{Writes Follow Reads })}
Данная модель согласованности гарантирует, что если процесс считывает значение v, которое пришло из записи w1, а затем выполняет запись w2, то запись w2 должна быть видна после w1. Как только вы что-то прочитали, вы не можете изменить прошлое этого чтения. Гарантируется полная доступность.

\subsection{Конвейерная Оперативная Память(англ.  \textit{PRAM, Pipeline Random Access Memory})}
PRAM пытается ослабить существующие когерентные модели памяти, чтобы получить лучший параллелизм (и, следовательно, производительность). Эта модель гарантирует, что любая пара записей, выполненных одним процессом, наблюдалась везде в том порядке, в котором процесс их выполнил; однако записи из разных процессов могут наблюдаться в разных порядках. 
\par
PRAM эквивалентен монотонному чтению, монотонной записи и чтению своих записей (смотреть далее).
Гарантируется частичная доступность.
Более формально, ПРАМ удовлетворяется, если порядок сеанса (порядок операций над каждым процессом) является подмножеством порядка видимости (какие операции видны данной операции).

\subsection{Монотонные чтения(англ.  \textit{Monotonic Reads})}
Эта модель согласованности гарантирует, что если процесс выполняет чтение r1, а затем r2, то r2 не может наблюдать состояние до записи, которая была отражена в r1.
Не применяется к операциям, выполняемым различными процессами, а только к операциям, выполняемым одним и тем же процессом.
Монотонное чтение может быть полностью доступно (все узлы могут совершать прогресс даже во время разрыва в сети)
\par
Более формально, можно говорить о монотонном чтении в терминах порядка сеанса (порядка операций, выполняемых одним и тем же процессом) и порядка видимости (какие записи видны для каких чтений). Для всех операций a, b и c, где b и c являются чтением, если a виден b, и b выполняется до и тем же процессом, что и c, то a должен быть виден c.

\subsection{Монотонные записи(англ.  \textit{Monotonic Writes})}
Эта модель согласованности гарантирует, что если процесс выполняет запись w1,  а затем w2, то все процессы наблюдают w1 до w2. Не применяется к операциям, выполняемым различными процессами, а только к  операциям, выполняемым одним и тем же процессом.
Есть полная доступность: даже во время разрыва сети все узлы могут совершать прогресс.

\subsection{Чтение своих записей(англ.  \textit{Read Your Writes})}
Этот уровень изоляции транзакций требует: если процесс выполняет запись w, то этот же процесс выполняет последующее чтение r, и тогда r должен наблюдать эффекты w.
Важно, что это модель не применяется к операциям, выполняемым различными процессами. Например, нет никакой гарантии, что если процесс 1 успешно запишет значение, то процесс 2 впоследствии будет наблюдать эту запись.
\par
Есть гарантия частичной доступности: если возникает разрыв сети, каждый узел может добиться прогресса (если клиент никогда не меняет сервер, с которым он взаимодействует).
Более формально: для любой записи и любого чтения, если запись происходит прямо перед чтением в данном сеансе (процессе), то запись должна быть видна для чтения. Другими словами, порядок сеанса (ограниченный только записью -> чтением) является подмножеством порядка видимости.

\section{Граф сериализации \cite{IsolationLevelDefinitions} \cite{IsolationLevelDefinitions2}}
Сначала определем различные типы конфликтов-зависимостей чтения/записи, которые могут возникать в базах данных, а затем определеим \textit{граф сериализации}(\textit{\textbf{DSG}}). Для удобства мы определим три типа зависимостей.
Здесь и далее $T_i/T_j$ - транзакции.
\subsection{Зависимость записи (англ. \textit{Directly Write-Depends})}
В дальнейшем будем обозначать данный тип \textit{ww}. Обозначение в \textit{DSG}: $T_i  \xrightarrow{\textit{ww}} T_j$
\par
Описание: $T_j$ зависит от $T_i$, когда $T_i$ устанавливает $x_i$, а $T_j$ устанавливает следующую версию x.
\subsection{Зависимость чтения (англ. \textit{Directly Read-Depends})}
В дальнейшем будем обозначать данный тип \textit{wr}. Обозначение в \textit{DSG}: $T_i  \xrightarrow{\textit{wr}} T_j$
\par
Описание: $T_j$ зависит от $T_i$,  когда или или:
\begin{itemize}
\item $T_i$ устанавливает $x_i$, $T_j$ читает $x_i$;
\item $T_i$ фиксирует изменение, а затем $T_j$ выполняет чтение на основе предикатов таким образом, что набор объектов, соответствующих предикату, изменяется фиксацией $T_i$.   Кроме того, $T_i$ --- это самая последняя транзакция, в которой было зафиксировано изменение, влияющее на соответствие $T_i$.
\end{itemize}

\subsection{Анти зависимость (англ. \textit{Directly Anti-Depends})}
В дальнейшем будем обозначать данный тип \textit{rw}. Обозначение в \textit{DSG}: $T_i  \xrightarrow{\textit{rw}} T_j$
\par
Описание: $T_j$ зависит от $T_i$,  когда или или:
\begin{itemize}
\item $T_i$ считывает некоторую версию $x_i$ объекта \textit{x}, а затем $T_j$  фиксирует следующую версию \textit{x} в истории версий;
\item $T_i$ выполняет чтение на основе предикатов, а $T_j$ перезаписывает это чтение(то есть фиксирует более позднюю (следующую) версию  объекта).
\end{itemize}

\subsection{Граф сериализации(англ. \textit{Direct Serialization Graph}, \textit{DSH})}
DSG имеет один узел для каждой совершенной транзакции. Направленные ребра между этими узлами представляют зависимости чтения/записи/анти. Транзакция $T_2$ зависит от $T_1$, если в графе есть путь от $T_1$ до $T_2$. 
\par
При постоении DSG начинаем  с добавления узлов для каждый зафиксированной транзакции. Затем добавляем ребро \textit{wr}, \textit{rw} или \textit{ww} зависимости для всех пар транзакций, если выполняются условия зависимости.

\section{Нарушения согласованности}
... какие проблемы бывают с согласованностью
(только те, которые были упомянуты в секции выше)

\subsection{грязная запись}
\subsection{грязное чтение}
\subsection{неповторяющееся чтение}
\subsection{фантомное чтение}
\subsection{Грязное обновление(англ. \textit{Dirty Update})}
???
запись переводит прерванное состояние в зафиксированное состояние.

\subsection{G0 (цикл записи, англ. \textit{Write Cycle})}
История показывает цикл записи, если ее граф  сериализации содержит цикл, полностью состоящий из ребер зависимости записи(\textit{ww}). Обратите внимание, что это определение охватывает циклы записи, в которых задействовано более 2 объектов.

\subsection{G-cursor}
G-cursor(x): граф направленной сериализации, ограниченный одним объектом x, содержит анти-зависимый цикл и по крайней мере одно ребро, зависимое от записи.

\subsection{G1}
G1: включает в себя три феномена: 
\begin{itemize}
\item G1a (прерванное чтение, англ. \textit{aborted read}): $T_2$ считывает некоторый объект (в том числе с помощью чтения предикатов), измененный $T_1$, и $T_1$ прерывается. Чтобы предотвратить прерывание чтения, если $T_2$ читает из $T_1$ и $T_1$ прерывается, $T_2$ также должен прерваться – известный как каскадное прерывание;
\item G1b (промежуточное чтение, англ. \textit{intermediate read}): $T_2$ считывает версию некоторого объекта (в том числе с помощью чтения предикатов), измененную $T_1$, и это не было окончательной модификацией этого объекта $T_1$. Чтобы предотвратить промежуточное чтение, транзакции могут быть разрешены к фиксации только в том случае, если они прочитали окончательные версии объектов из других транзакций;
\item G1c (циклический информационный поток, англ. \textit{сyclic information flow}): граф сериализации содержит направленный цикл, полностью состоящий из ребер зависимостей (чтение и запись). Если на $Т_1$ влияет $Т_2$, то нет никакого пути, по которому $Т_2$ также может влиять на $Т_1$.
\end{itemize}

\subsection{G2-item}
G2-item(anti-dependency cycle, цикл антизависимости) возникает, когда DSG содержит направленный цикл, имеющий одно или несколько ребер антизависимости(\textit{rw}). 

\chapter{Методология проверки согласованности распределенных систем}
Итак, в предудущей главе мы рассмотрели некоторые нарушения и аномалии,которые нарушают гарантии согласованности распределенной системы.Несмотря на то, что они встречаются довольно часто,их сложно обнаружить.  В этой главе мы рассмотрим инструмент,разработанный специально для проверки того, соответствует ли распределенная система своим гарантиям согласованности.
\section{Jepsen}
\includegraphics[scale=0.175]{jepsen.jpeg}
\par
Jepsen это библиотека для функционального языка Clojure.
\par
Jepsen проверяет систему, генерируя случайные последовательности операции (например, чтение, запись, cas) в распределенной системе, записывая метку времени и продолжительность каждой операции, а также создавая модель системы в памяти. А затем он пытается доказать, имеет ли история событий смысл с учетом модели.
Jepsen также может генерировать множество сбоев в распределенной системе, например, проблемы с сетью, уничтожение компонентов, а также генерацию случайной нагрузки.
\par
При запуске теста jepsen сначала подключается по ssh к каждому узлу, загрузит, распакует и настроит на них распределенную систему.
После запустятся клиентские и nemesis процессы. Во время теста в jepsen есть два типа процессов: один - клиент, который будет выполнять различные операции с системой (с интервалом и частотой, заданных в генераторе), а другой - nemesis, который будет вносить сбои и разрушения и выполнять восстановление системы. После завершения операций jepsen будет использовать checker (после jepsen 2.0 это будет elle), чтобы проверить правильность истории операций с определенными моделями согласованности.

\subsection{Jepsen and docker}
В данном исследовании мы будем запускать кластер Jepsen на одном компьютере, используя docker compose. 
Это упрощает и стандартизирует выполнение тестов. 
Репозиторий Jepsen предоставляет базовые настройки для запуска тестов в докере. Он поддерживает 3 вида контейнеров:  \newline
jepsen-control:  управляет другими узлами, настройкой и удалением, генерирует данные и сбои; \newline
jepsen-nX:  один из узлов в кластере(по умолчанию таких узлов 5); \newline
jepsen-node: используется агентом для создания сбоев (nemesis). 

\subsection{Возможные сбои}
сетевые разделы, изолирующие отдельные узлы; а также разделяющие кластер на мажоритарные и миноритарные компоненты
приостановка или разрушение случайного подмножества узлов
сбой часов

\subsection{Как анализировать результаты}
При каждом запуске jepsen создает новый каталог в store/ директории, и мы можем увидеть последние результаты в папке store/latest. Там лежат несколько файлов. history.txt содержит операции, которые выполнял тест. jepsen.log копия консоли для этого запуска, jepsen.log - журнал всех операций, выполненных jepsen к тестируемой системе, и наконец test.fressian это необработанные данные теста, включающие полную историю операций, timeline.html - это html документ, который показывает удобную временную шкалу операций. Эта шкала очень полезный инструмент для понимания порядка операций в тесте и выявления причин несогласованности результатов теста.
Синий цвет указывает на то, что операция прошла успешно, красный - на неудачную операцию (состояние системы не изменилось), а оранжевый - на неопределенную операцию.

\section{Elle}
\par
Elle --- это инструмент для анализа транзакций. Он способен автоматически выводить график логического порядка транзакций и искать циклы в этом графике для выявления нарушений согласованности. Например, если транзакции образуют логический цикл, то невозможно сказать, какая транзакция произошла до и после, а значит, нарушается гарантия линеаризуемости. 
Дополнительно проверяется наличие прерванных и промежуточных считываний и другие нарушения.
\par
Elle не является полным: он может не идентифицировать аномалии, которые присутствовали в тестируемой системе. Это следствие двух факторов:
\begin{itemize}
\item Elle проверяет истории, наблюдаемые в реальных базах данных, где результаты транзакций могут остаться незамеченными, а информация о времени может быть не такой точной, как хотелось бы.
\item Проверка сериализуемости является NP-полной; Elle намеренно ограничивает свои выводы теми, которые можно решить за линейное (или лог-линейное) время.
\end{itemize}
\par
\textbf{Список возможных аномалий}:
\begin{itemize}
\item G0 (цикл записи), 
\item G1a (прерванное чтение), 
\item G1b (промежуточное чтение), 
\item G1c (cyclic information flow, циклический поток информации), 
\item G-single (read skew, перекос чтения) ,
\item G2-item (anti-dependency cycle, цикл защиты от зависимостей).
\end{itemize}
Инструмент также умеет проверять согласованность внутри одной транзакции: то есть можно проверить, что транзакции считывают значения, соответствующие их собственным предыдущим записям, нет дублирующихся элементов и неожиданных элементов (например, элементов, которые никогда не были записаны).
\section{Обзор исследований, выполненных Jepsen}
Jepsen использовался для тестирования многих распределенных систем. 
Я ознакомилась с результатами некоторых из них.
\subsection{Etcd 3.4.3 \cite{etcdAnalyses} \cite{etcdTutorial}}
При изучении jepsen инструмента и его возможностей мы повторим эксперимент из туториала для тестирования ETCD(распределенное хранилище пар ключ-значение).
\par
\textbf{Дизайн тестов} \newline
Для тестирования etcd командой jepsen были разработаны следующие тесты: \par
\textit{register} тест:  тест выполняет случайные операции чтения, записи и сравнения (compare-and-set) по отдельным ключам. Оценка этих истории операций с помощью средства проверки линеаризуемости Knossos. \par
\textit{set} тест:  для того, чтобы обнаружить чтение устаревший данных, был разработан тест, который использовал cas  операцию для считывания набора целых чисел по одному ключу и добавление значения к этому набору. Мы одновременно читаем множество значений на протяжении всего теста. В конце теста ищем случаи, когда элемент, который теоретически должен быть в наборе, не появляется при чтении. Эти случаи использовались для количественного измерения устаревших чтений и потерянных обновлений. \par
\textit{append} тест: для проверки строгой сериализуемости был разработан тест, в котором транзакции параллельно читают и добавляют в списки уникальные целые числа. Каждый список храниться по уникальному ключу.  Мы выполняем append каждой транзакции, читая каждый ключ, который должен быть изменен, в одной транзакции, затем пишем эти ключи и выполняем чтения во второй транзакции, что гарантирует что никакие записанные ключи не изменились с первого чтения. В конце строится график зависимостей между транзакциями на основе приоритета в реальном времени и отношений между чтениями и добавлениями, ищутся циклы в этом графике. \par
\textit{lock} тест: etcd предоставляет возможность блокировки. Тест оценивает надежность функционала блокировки двумя способами: 1) генерация случайных запросов на блокировку и разблокировку. После история операций проверяется с помощью Knossos, чтобы увидеть, являются ли блокировки линеаризуемыми; 2) для получения количественного представления о том, как часто блокировки могут отказывать, тест использует блокировку для обеспечения взаимного исключения обновления набора значений (те обновление в критической секции) и искали (lost updates) потерянные обновления этого набора. \par
\textit{watch} тест: чтобы убедиться, что каждое обновление ключей происходит в правильном порядке, тест создает один ключ и вслепую устанавливать для него уникальные целочисленные значения в течении теста. Тем временем клиенты параллельно наблюдают за этим ключом в течении нескольких секунд за раз. И каждый раз, когда клиент запускал наблюдение, оно начиналось с того места, где в последний раз закончилось. В конце теста было проверено, что каждый клиент наблюдал точно такую же последовательность обновлений ключа. 
\par
\textbf{Результаты тестирования}
\par
В документации etcd утверждает, что операции сериализуемые и линеаризуемые. 
И etcd действительно соответствует данным требованиям, даже если в процесс были добавлены паузы, сбои, сдвиги часов и сетевые разделы. А при выполнении чтения с установленным флагом serializable возможно устаревшее чтение, как и предполагает документация.
Также было выявлено, что блокировки небезопасны: несколько клиентов могут удерживать одновременно одну и ту же блокировку.
Хотя стоит заметить, что Jepsen может доказать только лишь наличие ошибок, а не их отсутствие.
\par
Для того, чтобы поближе познакомиться с Jepsen и Clojure и в дальнейшем понять, как выполнить с помощью Jepsen свое собственное исследование, мы, следуя туториалу,реализовали set и register тест.  \par
Для того, чтобы развернуть jepsen  кластер, мы использовали docker compose. 
Основные используемые библиотеки - Jepsen и Verschlimmbesserung (библиотека для взаимодействия с etcd). 
\textbf{Этапы подготовки тестов}
\begin{itemize}
\item настройка автоматической установки тестируемой системы на рабочие узлы (В Jepsen это делается путем указания узлу управления(control node) загружать двоичные файлы с URL-адреса с помощью встроенной функции Jepsen install-archive);
\item написание клиента для взаимодействия с распределенной системой (как к ней подключиться, как выполнять операции над системой). 
\item добавление сбоев в систему с помощью специального клиента jepsen.nemesis
\item анализ истории операций с помощью модели
\end{itemize}
\par
В результате запуска этих тестов никаких аномалий не было обнаружено.

%\subsection{MongoDB 4.2.6}
%\subsection{PostgreSQL 12.3}

\chapter{Исследование согласованности Azure Cosmos DB}
\section{Azure Cosmos DB}
информация о базе данных
\section{Уровни согласованности \cite{cosmosConsistencyLevels}}
Одной из особенностей Azure Cosmos DB является то, что она позволяет выбрать один из 5 уровней согласованности, который будет удовлетворять нужным критериям.
\subsection{Строгая (англ.  \textit{strong})}
Данные синхронно реплицируются на все реплики в режиме реального времени. Гарантирует линеаризацию. Это означает, что порядок операций сохраняется, и считывания гарантированно возвращают самую последнюю версию элемента в базе данных. Клиент всегда получает последние изменения в данных по запросу. Никогда не будет видима незафиксированная или частично измененная запись. Самая низкая производительность и доступность.
\subsection{Ограниченное устаревание(англ.  \textit{bounded staleness})}
Данные реплицируются асинхронно с заданным окном устаревания, определяемым либо количеством записей, либо периодом времени. Запрос на чтение может отставать либо на определенное количество операций записи, либо на заранее определенный период времени. Однако при чтении гарантируется соблюдение последовательности данных. По мере приближения окна устаревания репликация данных запускается в учетной записи базы данных, заставляющей базу данных обновлять новые записи с момента последнего изменения. Низкая доступность из-за задержки синхронизации разных регионов. Более хорошая производительность.
\subsection{Сеанс(англ.  \textit{session})}
Это уровень согласованности по умолчанию. Это обеспечивает сильную согласованность для сеанса приложения с одним и тем же токеном сеанса. Это означает, что все, что написано сеансом, также вернет последнюю версию для чтения из того же сеанса. Доступность данных относительно высока и более низкой задержкой и более высокой пропускной способностью, чем bounded staleness. Данные из других сеансов поступают в правильном порядке, просто не гарантируется, что они будут актуальными.
\subsection{Постоянный префикс(англ.  \textit{consistent prefix})}
Эта модель согласованности аналогична bounded staleness, только без гарантии задержки. Реплики гарантируют согласованность и порядок записи, однако данные не всегда актуальны. Эта модель гарантирует, что пользователь никогда не увидит неупорядоченную запись. Высокая доступность и низкая задержка.
\subsection{Случайная(англ.  \textit{eventual})}
Для операции чтения нет гарантии порядка данных, а также отсутствует гарантия того, сколько времени может потребоваться для репликации данных.  Это слабая форма согласованности, так как могут быть считаны более старые значения чем те, которые были считаны раньше.
Высокая доступность, самая высокая пропускная способность и низкая задержка.

\section{Дизайн теста}
Мы разработали тест с использованием библиотеки для тестирования распределенных систем Jepsen. Будем использовать его для оценки безопасности транзакций в Azure Cosmos DB. 
\par
\textit{Append} тест
\par
Генератор транзакций Jepsen генерировал транзакции, состоящие из последовательности операций. Длину последовательности операций можно настраивать, для запуска тестов использовалась длина 4. Каждая операция в последовательности --- это либо чтение массива значений по ключу id, либо добавление уникального целого числа в массив значений по ключу id. 
Далее, используя Elle для анализа транзакций, Jepsen выводил зависимости между транзакциями и искал циклы для выявления аномалий. 

\section{О реализации транзакций в Azure Cosmos DB}
\subsection{TransactionalBatch}
??? РЕДАКТИРОВАТЬ
TransactionalBatch (увеличение производительности; пакет транзакций описывает группу операций, которые должны либо успешно выполниться, либо завершиться сбоем с одним и тем же ключом секции в контейнере. Если все операции выполняются успешно в том порядке, в котором они описаны в транзакционной пакетной операции, транзакция будет зафиксирована. Однако при сбое любой операции выполняется откат всей транзакции.)

При тестировании транзакций с использованием TransactionalBatch Elle обнаружила следующие аномалии:
\begin{itemize}
\item внутренняя несогласованность (англ. \textit{Internal Inconsistency}) --- транзакция не соблюдает свои собственные предыдущие операции чтения и записи.
\item несогласованный порядок версий (англ.\textit{Inconsistent Version Orders}) --- правила вывода предполагают циклический порядок обновления одного ключа.
\end{itemize}

Также, из отношений между аномалиями Elle\cite{Kingsbury2020ElleII} можно заключить, что из обнаружение в истории  \textit{nconsistent Version Orders} аномалии следует, что G1a аномалия там также присустствует.
\par
Кроме того, на уровнях \textbf{Ограниченное устаревания} и \textbf{Случайная} была обнаружена \textit{G-item} аномалия. 
Напомним, что обанаружение этой аномалии означает, что DSG(H) содержит направленный цикл с одним или несколькими ребрами анти зависимости \cite{IsolationLevelDefinitions}.

Транзакции теряют подтвержденные записи.  Кроме того, оказывается, что транзакции не изолированы. То есть,транзакции в такой реализации могли влиять на результаты других транзакций.
А значит, TransactionalBatch в нашей задаче использовать нельзя.

\subsection{Хранимые процедуры(англ. \textit{Stored procedures})}
Azure Cosmos DB обеспечивает транзакционное выполнение JavaScript кода. При использовании API SQL в Azure Cosmos DB можно писать хранимые процедуры, триггеры и определяемые пользователем функции (UDF) на языке JavaScript.
Помимо того, что написанный JavaScript код будет выполняться атомарно, также данный  способ реализации транзакций обещает хорошую производительность. Можно назвать следующие преимущества:
\begin{itemize}
\item \textit{пакетная обработка} --- это сократит затраты сетефого трафика и накладные расходы на хранение
\item  \textit{предварительная компиляция} --- хранимые процедуры, триггеры и определяемые пользователем функции неявно предварительно скомпилированы в формат байтового кода, чтобы избежать затрат на компиляцию во время каждого вызова скрипта. Благодаря предварительной компиляции скорость хранимой процедуры высокая, а занимаемая память небольшая.
\end{itemize}

\textbf{Согласованность данных}
\par
Хранимые процедуры и триггеры всегда выполняются на основной реплике контейнера Azure Cosmos. Эта возможность гарантирует, что операции чтения в хранимых процедурах обеспечивают сильную согласованность. 

\section{Результаты}
При тестировании Azure Cosmos DB, где мы реализовали транзакции с помощью хранимых процедур(англ. \textit{Stored procedures}), на всех уровнях согласованности были замечены G2-item  аномалии. Давайте посмотрим на примеры таких аномалий для разных уровней согласованности и попытаемся понять,противоречит ли данная аномалия требованиям к Azure Cosmos DB, заявленным в документации.
\subsection{Строгая (англ.  \textit{strong})}
\subsubsection{Пример 1}
\begin{figure}[H]
  \includegraphics[width=\textwidth]{strong/6.png}
  \caption{G2-item 1(сгенерировано Elle)}
\end{figure}
\par

\begin{lstlisting}[caption={Пояснение к G2-item 1 аномалии (сгенерировано Elle)}]
Let:
  T1 = {:type :ok, :f :txn, :value [[:r 42 [2 1 5 3 4 6 7 8 9 10 11 12 13 14 16 17 18 19 20 21 15 23 22 25 26 24 27 28 29 30 31 34 35 32 37 38 40 36 39 33 41]] [:append 43 23] [:r 38 [1 2 3 4 5 6 7 8 9 10 11 12 14 15 13 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 36 35 37 39 40 38 42 43 44 41 45 46 47 48 52 50 51 53 49 54 55 56 57 58 59 60 61 64 62 65 63 66 67 68 69 70 71 72 73 74 75 77 78 80 76 79 81 82 83 84 85 86 87 88 89 91 92 90 94 95 93 96 97 98 99 100 101 102 103]]], :time 97040365716, :process 6, :index 7502}
  T2 = {:type :ok, :f :txn, :value [[:r 38 [1 2 3 4 5 6 7 8 9 10 11 12 14 15 13 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 36 35 37 39 40 38 42 43 44 41 45 46 47 48 52 50 51 53 49 54 55 56 57 58 59 60 61 64 62 65 63 66 67 68 69 70 71 72 73 74 75 77 78 80 76 79 81 82 83 84 85 86 87 88 89 91 92 90 94 95 93 96 97 98 99 100 101 102 103]] [:append 42 42] [:r 37 [1 2 4 3 5 6 7 8 9 10 11 12 13 14 16 15 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 54 53 55 56]]], :time 97047346936, :process 12, :index 7505}
  T3 = {:type :ok, :f :txn, :value [[:r 43 [1 2 3 6 7 8 4 5 10 11 15 12 13 14 18 9 20 16 17 21 22 19]] [:r 43 [1 2 3 6 7 8 4 5 10 11 15 12 13 14 18 9 20 16 17 21 22 19]] [:append 37 57] [:r 42 [2 1 5 3 4 6 7 8 9 10 11 12 13 14 16 17 18 19 20 21 15 23 22 25 26 24 27 28 29 30 31 34 35 32 37 38 40 36 39 33 41]]], :time 97040333149, :process 7, :index 7501}

Then:
  - T1 < T2, because T1 did not observe T2's append of 42 to 42.
  - T2 < T3, because T2 did not observe T3's append of 57 to 37.
  - However, T3 < T1, because T3 did not observe T1's append of 23 to 43: a contradiction!
\end{lstlisting}
\subsubsection{Пример 2}
\begin{figure}[H]
  \includegraphics[width=\textwidth]{strong/42.png}
  \caption{G2-item 2(сгенерировано Elle)}
\end{figure}
\par

\begin{lstlisting}[caption={Пояснение к G2-item 2 аномалии (сгенерировано Elle)}]
Let:
  T1 = {:type :ok, :f :txn, :value [[:r 8 [5 9 8 2 3 4 14 10 11 15 12 13 16 18 17 20 21 6 7]] [:append 7 6]], :time 7452779704, :process 11, :index 77}
  T2 = {:type :ok, :f :txn, :value [[:r 9 [1 4 3 6 5 7 8 9 10 11 12 15 16]] [:append 8 23] [:r 7 [1 2 4 3 5]]], :time 7432207522, :process 12, :index 75}

Then:
  - T1 < T2, because T1 did not observe T2's append of 23 to 8.
  - However, T2 < T1, because T2 did not observe T1's append of 6 to 7: a contradiction!
\end{lstlisting}
\subsubsection{Пример 3}

\begin{figure}[H]
  \includegraphics[width=\textwidth]{strong/53.png}
  \caption{G2-item 3(сгенерировано Elle)}
\end{figure}
\par

\begin{lstlisting}[caption={Пояснение к G2-item 3 аномалии (сгенерировано Elle)}]
Let:
  T1 = {:type :ok, :f :txn, :value [[:append 17 18] [:append 17 19] [:append 16 39] [:r 14 [3 4 7 8 9 1 2 5 6 10 11 12 13 15 16 17 18 20 21 24 22 23 25 26 27 28 14 29 19 32 33 30 31 36 37 34 39 40 35 38 41 42 43 44 45 46 51 54 55 50 56 58 59 47 48 49 60 61 57 65 66 67 62 63 64 52 53 69 72 70 71 76 77 78 75 79 80]] [:r 17 [4 5 1 7 9 10 11 12 13 14 2 3 15 16 17 8 18 19]] [:append 17 20]], :time 21365086252, :process 0, :index 983}
  T2 = {:type :ok, :f :txn, :value [[:append 1 5] [:r 6 [1 3 2 4 7 6 8 9 10 5 12 13 14 15 16 17 11 18 21 22 19 20 25 26 27 28 29 30 23 24 31 33 34 35 32 36 37 39 38 41 40 42 43 44 45 47 46 49 48 50 51 52 53 54 55 56 57 59 58 60 61 62 63 64 65 66 67 71 68 69 70 74 72 73 75 76 77 78 80 85 86 88 79 81 82 83 84 89 90 92 93 87]] [:append 14 81] [:append 14 82]], :time 21354990109, :process 8, :index 981}
  T3 = {:type :ok, :f :txn, :value [[:append 14 85] [:r 17 [4 5 1 7 9 10 11 12 13 14 2 3 15 16 17 8]] [:r 17 [4 5 1 7 9 10 11 12 13 14 2 3 15 16 17 8]] [:r 14 [3 4 7 8 9 1 2 5 6 10 11 12 13 15 16 17 18 20 21 24 22 23 25 26 27 28 14 29 19 32 33 30 31 36 37 34 39 40 35 38 41 42 43 44 45 46 51 54 55 50 56 58 59 47 48 49 60 61 57 65 66 67 62 63 64 52 53 69 72 70 71 76 77 78 75 79 80 81 82 85]] [:r 16 [2 3 4 5 6 7 8 9 10 1 14 15 13 17 11 12 19 16 20 18 24 21 22 23 25 27 28 33 31 32 26 29 30 36 37 38 35]] [:append 14 86] [:r 17 [4 5 1 7 9 10 11 12 13 14 2 3 15 16 17 8]]], :time 21376173126, :process 9, :index 987}

Then:
  - T1 < T2, because T1 did not observe T2's append of 81 to 14.
  - T2 < T3, because T3 appended 85 after T2 appended 82 to 14.
  - However, T3 < T1, because T3 did not observe T1's append of 18 to 17: a contradiction!
\end{lstlisting}
\subsubsection{Пример 4}

\begin{figure}[H]
  \includegraphics[width=\textwidth]{strong/6-2.png}
  \caption{G2-item 4(сгенерировано Elle)}
\end{figure}
\par

\begin{lstlisting}[caption={Пояснение к G2-item 4 аномалии (сгенерировано Elle)}]
Let:
  T1 = {:type :ok, :f :txn, :value [[:r 12 [2 3 4 5 6 1 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 23 22 25 26 24 27 28 29 30 31 32 33 34 35 36 37 38 39 40 42]] [:append 7 127]], :time 34263295593, :process 11, :index 2331}
  T2 = {:type :ok, :f :txn, :value [[:append 12 45]], :time 34263249662, :process 13, :index 2329}
  T3 = {:type :ok, :f :txn, :value [[:r 12 [2 3 4 5 6 1 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 23 22 25 26 24 27 28 29 30 31 32 33 34 35 36 37 38 39 40 42 45]] [:r 7 [1 4 2 6 5 3 8 7 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 27 26 28 29 30 31 33 35 32 36 34 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 72 73 71 74 75 77 78 76 79 80 81 82 84 83 85 86 87 88 89 90 91 92 93 94 95 96 97 99 100 98 101 102 103 104 105 106 108 107 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126]]], :time 34263278536, :process 4, :index 2330}

Then:
  - T1 < T2, because T1 did not observe T2's append of 45 to 12.
  - T2 < T3, because T3 observed T2's append of 45 to key 12.
  - However, T3 < T1, because T3 did not observe T1's append of 127 to 7: a contradiction!
\end{lstlisting}

\subsubsection{Что это значит?}
???

\subsection{Ограниченное устаревание(англ.  \textit{bounded staleness})}
\subsubsection{G2-item}
пример аномалии с ребрами rw-rw. Также встречаются (сильно реже) аномалии с ребрами ww и wr (стоит добавить примеры?)

\begin{figure}[H]
  \includegraphics[width=\textwidth]{staleness/32.png}
  \caption{G2-item(сгенерировано Elle)}
\end{figure}
\par

\begin{lstlisting}[caption={Пояснение к G2-item аномалии (сгенерировано Elle)}]
Let:
  T1 = {:type :ok, :f :txn, :value [[:append 42 1] [:r 41 [1 2 3]] [:r 41 [1 2 3]] [:r 41 [1 2 3]]], :time 89283544982, :process 2, :index 7317}
  T2 = {:type :ok, :f :txn, :value [[:append 39 31] [:r 42 []] [:append 41 4] [:r 42 []]], :time 89301402301, :process 4, :index 7319}

Then:
  - T1 < T2, because T1 did not observe T2's append of 4 to 41.
  - However, T2 < T1, because T2 observed the initial (nil) state of 42, which T1 created by appending 1: a contradiction!
\end{lstlisting}

\par
Довольно редкие, статистически не значимые аномалии.
\subsubsection{Грязное обновление (англ. \textit{Dirty Update})}
\textit{Пример}: по ключу 4 транзакция T1 пыталась добавить значение 4, во время выполнения транзакции произошла ошибка и статус операции был определен как fail. Транзакция T2 далее записала по ключу 4 значение 5.  Далее другие транзакции увидели по ключу 4 значения [4 5].
\subsubsection{G1a: прерванное чтение(англ. \textit{Aborted read})}
\begin{lstlisting}[caption={Пример G1a аномалии}]
{:op {:type :ok,
	:f :txn,
	:value [[:append 9 145]
		   [:r 6 [1 2 3 4 5 6 7 8 9 10]]],
	:time 27666818490,
	:process 2,
	:index 501},
 :mop [:r 6 [1 2 3 4 5 6 7 8 9 10]],
 :writer {:type :fail,
	     :f :txn,
	     :value [[:r 8 nil]
		        [:append 4 4]
		        [:append 6 8]],
	     :time 24489725317,
	     :process 3,
	     :error :cosmos-exception,
              :index 463},
 :element 8}
\end{lstlisting}
\par

\subsubsection{Что это значит?}
\par
Грязное обновление и G1a аномалии попадают в окно устаревания.Поэтому не нарушают гарантий согласованности,которые заявлены для данного уровня.
\par
G2-item?

\subsection{Сеанс(англ.  \textit{session})}
\subsubsection{G2-item}
пример аномалии с ребрами rw. Также встречаются (сильно реже) аномалии с ребрами ww и wr(стоит добавить примеры?)
\begin{figure}[H]
  \includegraphics[width=\textwidth]{session/32.png}
  \caption{G2-item(сгенерировано Elle)}
\end{figure}
\par
\begin{lstlisting}[caption={Пояснение к G2-item аномалии (сгенерировано Elle)}]
Let:
  T1 = {:type :ok, :f :txn, :value [[:append 7 5] [:append 8 8] [:r 9 [4 5 1 6 10 2 11 8 12 7 3 13 9]]], :time 7466652176, :process 1, :index 58}
  T2 = {:type :ok, :f :txn, :value [[:append 9 19] [:r 8 [2 3 1 4 5]]], :time 7466700880, :process 6, :index 59}

Then:
  - T1 < T2, because T1 did not observe T2's append of 19 to 9.
  - However, T2 < T1, because T2 did not observe T1's append of 8 to 8: a contradiction!
\end{lstlisting}
\subsubsection{Что это значит?}
???

\subsection{Постоянный префикс(англ.  \textit{consistent prefix})}
\subsubsection{G2-item}
пример аномалии с ребрами rw, ww и wr. Чаще всего встречается G2-аномалия с ребрами rw-rw.
\begin{figure}[H]
  \includegraphics[width=\textwidth]{prefix/7.png}
  \caption{G2-item(сгенерировано Elle)}
\end{figure}
\par
\begin{lstlisting}[caption={Пояснение к G2-item аномалии (сгенерировано Elle)}]
Let:
  T1 = {:type :ok, :f :txn, :value [[:r 48 [2 3 4 5 6 7 8 9 1 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 27 28 29 30 31 26]] [:r 47 [1 4 3 7 8 9 2 13 14 15 10 11 12 18 17 5 6 19 22 20 16 23 21 24 26 30 25 31 32 35 38 28 33 34 27 39 40 36 37 42 43 44 46 45 48 41 29 49 51 50 52 57 54 55 47 58 60 53 62 59 56 63 64 61 65 67]] [:r 48 [2 3 4 5 6 7 8 9 1 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 27 28 29 30 31 26]] [:r 48 [2 3 4 5 6 7 8 9 1 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 27 28 29 30 31 26]] [:append 4 90] [:r 48 [2 3 4 5 6 7 8 9 1 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 27 28 29 30 31 26]]], :time 84564390536, :process 7, :index 5394}
  T2 = {:type :ok, :f :txn, :value [[:append 48 32] [:r 46 [1 3 4 5 6 2 8 9 10 7 11 13 12 14 15 17 21 22 18 19 16 23 24 25 26 27 29 30 31 20 33 36 35 32 28 34 38 37 39 40 41 42 44]] [:append 37 76]], :time 84573458348, :process 0, :index 5397}
  T3 = {:type :ok, :f :txn, :value [[:r 47 [1 4 3 7 8 9 2 13 14 15 10 11 12 18 17 5 6 19 22 20 16 23 21 24 26 30 25 31 32 35 38 28 33 34 27 39 40 36 37 42 43 44 46 45 48 41 29 49 51 50 52 57 54 55 47 58 60 53 62 59 56 63 64 61 65 67]] [:r 48 [2 3 4 5 6 7 8 9 1 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 27 28 29 30 31]] [:append 46 45] [:r 47 [1 4 3 7 8 9 2 13 14 15 10 11 12 18 17 5 6 19 22 20 16 23 21 24 26 30 25 31 32 35 38 28 33 34 27 39 40 36 37 42 43 44 46 45 48 41 29 49 51 50 52 57 54 55 47 58 60 53 62 59 56 63 64 61 65 67]]], :time 84560168742, :process 4, :index 5391}
  T4 = {:type :ok, :f :txn, :value [[:append 48 26] [:r 48 [2 3 4 5 6 7 8 9 1 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 27 28 29 30 31 26]]], :time 84560623148, :process 8, :index 5392}

Then:
  - T1 < T2, because T1 did not observe T2's append of 32 to 48.
  - T2 < T3, because T2 did not observe T3's append of 45 to 46.
  - T3 < T4, because T3 did not observe T4's append of 26 to 48.
  - However, T4 < T1, because T1 observed T4's append of 26 to key 48: a contradiction!
\end{lstlisting}
\subsubsection{Что это значит?}
???

\subsection{Случайная(англ.  \textit{eventual})}
Также встречается G2-item аномалия с ребрами rw(чаще всего), wr и ww.
\subsubsection{Что это значит?}

\chapter{Заключение}
Выводы
???
\bibliographystyle{unsrt}
\bibliography{references}


\end{document}
